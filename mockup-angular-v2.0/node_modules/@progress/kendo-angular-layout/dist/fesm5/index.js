/**-----------------------------------------------------------------------------------------
* Copyright Â© 2019 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { ChangeDetectorRef, Component, ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, Host, HostBinding, HostListener, Inject, Injectable, Input, NgModule, NgZone, Optional, Output, QueryList, Renderer2, SkipSelf, TemplateRef, ViewChild, ViewChildren, ViewEncapsulation, isDevMode } from '@angular/core';
import { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';
import { DraggableDirective, DraggableModule, Keys, hasObservers } from '@progress/kendo-angular-common';
import { AUTO_STYLE, AnimationBuilder, animate, state, style, transition, trigger } from '@angular/animations';
import { BehaviorSubject, Subject, Subscription, of } from 'rxjs';
import { __assign, __extends } from 'tslib';
import { delay, filter, map, switchMap, take, takeUntil, tap } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

/**
 * Represents the expand modes of the PanelBar.
 * By default, the expand mode is set to `multiple`.
 */
var PanelBarExpandMode;
(function (PanelBarExpandMode) {
    /**
     * Allows you to expand only one item at a time.
     * When you expand an item, the item that was previously expanded is coll.
     */
    PanelBarExpandMode[PanelBarExpandMode["Single"] = 0] = "Single";
    /**
     * Allows you to expand only one item at a time and requires you to set the `height` property.
     * The expanded area occupies the entire height of the PanelBar.
     */
    PanelBarExpandMode[PanelBarExpandMode["Full"] = 1] = "Full";
    /**
     * The default mode of the PanelBar.
     * Allows you to expand more than one item at a time. Items can also be toggled.
     */
    PanelBarExpandMode[PanelBarExpandMode["Multiple"] = 2] = "Multiple";
    /**
     * By default, the expand mode is set to `multiple`.
     */
    PanelBarExpandMode[PanelBarExpandMode["Default"] = 2] = "Default";
})(PanelBarExpandMode || (PanelBarExpandMode = {}));

/**
 * @hidden
 */
var nextPanelbarId = 0;
/**
 * @hidden
 */
var PanelBarService = /** @class */ (function () {
    function PanelBarService() {
        this.parentSource = new Subject();
        this.keepContentSource = new BehaviorSubject(false);
        this.childSource = new Subject();
        this.parent$ = this.parentSource.asObservable();
        this.children$ = this.childSource.asObservable();
        this.keepContent$ = this.keepContentSource.asObservable();
        this.pbId = nextPanelbarId++;
    }
    PanelBarService.prototype.onKeepContent = function (keepContent) {
        this.keepContentSource.next(keepContent);
    };
    PanelBarService.prototype.onSelect = function (event) {
        this.childSource.next(event);
    };
    PanelBarService.prototype.onFocus = function () {
        this.parentSource.next(true);
    };
    PanelBarService.prototype.onBlur = function () {
        this.parentSource.next(false);
    };
    PanelBarService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    PanelBarService.ctorParameters = function () { return []; };
    return PanelBarService;
}());

/**
 * Represents the content template of the declaratively initialized PanelBar items.
 * The content can be expanded or collapsed through the item.
 */
var PanelBarContentDirective = /** @class */ (function () {
    function PanelBarContentDirective(templateRef) {
        this.templateRef = templateRef;
    }
    PanelBarContentDirective.decorators = [
        { type: Directive, args: [{
                    selector: "[kendoPanelBarContent]"
                },] },
    ];
    /** @nocollapse */
    PanelBarContentDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return PanelBarContentDirective;
}());

/**
 * Represents the template directive of the PanelBar which helps to customize the item title
 * ([more information and example]({% slug templates_panelbar %}#toc-customizing-the-appearance-of-the-title)).
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *        <kendo-panelbar>
 *            <kendo-panelbar-item [title]="'Paris'" [expanded]="true">
 *                <ng-template kendoPanelBarItemTitle>
 *                    Additional Content
 *                </ng-template>
 *            </kendo-panelbar-item>
 *        </kendo-panelbar>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
var PanelBarItemTitleDirective = /** @class */ (function () {
    function PanelBarItemTitleDirective(templateRef) {
        this.templateRef = templateRef;
    }
    PanelBarItemTitleDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoPanelBarItemTitle]'
                },] },
    ];
    /** @nocollapse */
    PanelBarItemTitleDirective.ctorParameters = function () { return [
        { type: TemplateRef, decorators: [{ type: Optional }] }
    ]; };
    return PanelBarItemTitleDirective;
}());

/**
 * @hidden
 */
var ITEM_INDEX = 'data-kendo-drawer-index';

/**
 * @hidden
 */
var isPresent = function (value) { return value !== null && value !== undefined; };

var focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
/**
 * @hidden
 */
var isFocusable = function (element) {
    if (element.tagName) {
        var tagName = element.tagName.toLowerCase();
        var tabIndex = element.getAttribute('tabIndex');
        var skipTab = tabIndex === '-1';
        var focusable = tabIndex !== null && !skipTab;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled && !skipTab;
        }
        return focusable;
    }
    return false;
};
/**
 * @hidden
 */

/**
 * @hidden
 */
var closestInScope = function (target, predicate, scope) {
    while (target && target !== scope && !predicate(target)) {
        target = target.parentNode;
    }
    if (target !== scope) {
        return target;
    }
};
/**
 * @hidden
 */
var itemIndex = function (item) { return +item.getAttribute(ITEM_INDEX); };
/**
 *
 * @hidden
 */
var hasItemIndex = function (item) { return isPresent(item.getAttribute(ITEM_INDEX)); };
/**
 * @hidden
 */
var closestItem = function (target, scope) { return closestInScope(target, hasItemIndex, scope); };

/**
 * @hidden
 */
var nextId = 0;
/**
 * Represents the items of the PanelBar.
 */
var PanelBarItemComponent = /** @class */ (function () {
    function PanelBarItemComponent(parent, eventService, element) {
        var _this = this;
        this.parent = parent;
        this.eventService = eventService;
        this.element = element;
        /**
         * Sets the title of the PanelBar item ([see example]({% slug items_panelbar %}#toc-titles)).
         */
        this.title = 'Untitled';
        /**
         * Allows the component to set the `"id"` property to each item.
         * Used to set the `id` attributes of the nested elements and to enable the WAI-ARIA support.
         */
        this.id = "default-" + nextId++;
        /**
         * Defines the icon that will be rendered next to the title ([see example]({% slug items_panelbar %}#toc-title-icons)).
         */
        this.icon = '';
        /**
         * Defines  the icon that will be rendered next to the title by using a custom CSS class
         * ([see example]({% slug items_panelbar %}#toc-title-icons)).
         */
        this.iconClass = '';
        /**
         * Defines the location of the image that will be displayed next to the title
         * ([see example]({% slug items_panelbar %}#toc-title-images)).
         */
        this.imageUrl = '';
        /**
         * When set to `true`, disables a PanelBar item ([see example]({% slug items_panelbar %}#toc-disabled-state)).
         */
        this.disabled = false;
        /**
         * Sets the selected state of a PanelBar item ([see example]({% slug items_panelbar %}#toc-selected-state)).
         */
        this.selected = false;
        this.keepContent = false;
        this.hasChildItems = false;
        this.hasItems = false;
        this.hasContent = false;
        this.state = "inactive";
        this.role = "treeitem";
        this.titleAttribute = null; // tslint:disable-line
        this.focused = false;
        this.wrapperFocused = false;
        this.subscriptions = new Subscription(function () { });
        this._expanded = false;
        this.subscriptions.add(eventService.parent$.subscribe(function (focused) { return _this.onWrapperFocusChange(focused); }));
        this.subscriptions.add(eventService.keepContent$.subscribe(function (keepContent) { return _this.keepContent = keepContent; }));
        this.wrapperFocused = parent ? parent.focused : false;
    }
    Object.defineProperty(PanelBarItemComponent.prototype, "expanded", {
        get: function () {
            return this._expanded;
        },
        /**
         * When set to `true`, expands the PanelBar item ([see example]({% slug items_panelbar %}#toc-expanded-state)).
         */
        set: function (value) {
            var activeState = this.animate ? "active" : "activeWithoutAnimation";
            this.state = value ? activeState : "inactive";
            if (!this.keepContent) {
                this.toggleExpandedChildAnimations(value);
            }
            this._expanded = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "animate", {
        get: function () {
            return this.eventService.animate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "kItemClass", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "kStateDefaultClass", {
        get: function () {
            return !this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "kStateDisabledClass", {
        get: function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "kStateExpandedClass", {
        get: function () {
            return !this.disabled && this.expanded && (this.hasChildItems || this.hasContent);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "itemId", {
        get: function () {
            return 'k-panelbar-' + this.eventService.pbId + '-item-' + this.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "ariaExpanded", {
        get: function () {
            return (this.hasChildItems || this.hasContent) ? !this.disabled && this.expanded : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "ariaSelected", {
        get: function () {
            return !this.disabled && this.selected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "ariaDisabled", {
        get: function () {
            return this.disabled ? true : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarItemComponent.prototype, "titleTemplate", {
        /**
         * @hidden
         */
        get: function () {
            return this.titleTemplates.length > 0 ? this.titleTemplates.toArray()[0].templateRef : undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.headerHeight = function () {
        return this.element.nativeElement.offsetHeight - (this.contentWrapper ? this.contentWrapper.nativeElement.offsetHeight : 0);
    };
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.ngAfterContentChecked = function () {
        this.hasItems = this.items && this.items.filter(function (item) { return !item.hidden; }).length > 0;
        this.hasChildItems = this.contentItems.length > 1 || this.hasItems;
        this.hasContent = (this.contentTemplate !== undefined && this.contentTemplate.length > 0) ||
            this.content !== undefined;
        this.validateConfiguration();
    };
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.ngAfterViewChecked = function () {
        var _this = this;
        if (this.items) {
            this.childrenItems = this.viewChildItems.toArray();
        }
        else {
            this.childrenItems = this.contentItems.filter(function (item) { return item !== _this; });
        }
    };
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.onItemAction = function () {
        if (!this.disabled) {
            this.eventService.onSelect(this);
        }
    };
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.onItemClick = function (e) {
        if (!isFocusable(e.target)) {
            this.onItemAction();
        }
    };
    Object.defineProperty(PanelBarItemComponent.prototype, "iconClasses", {
        /**
         * @hidden
         */
        get: function () {
            var _a;
            var icon = this.icon ? 'k-i-' + this.icon : null;
            return _a = {}, _a[icon || this.iconClass] = true, _a;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.serialize = function () {
        return {
            content: this.content,
            disabled: this.disabled,
            expanded: this.expanded,
            focused: this.focused,
            icon: this.icon,
            iconClass: this.iconClass,
            id: this.id,
            imageUrl: this.imageUrl,
            selected: this.selected,
            title: this.title
        };
    };
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.subTreeViewItems = function () {
        var subTree = [];
        this.viewChildItems.forEach(function (item) {
            subTree = subTree.concat(item.subTreeViewItems());
            subTree.push(item);
        });
        return subTree;
    };
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.validateConfiguration = function () {
        if (isDevMode()) {
            if (this.content && (this.contentTemplate !== undefined && this.contentTemplate.length > 0)) {
                throw new Error("Invalid configuration: mixed template components and component property.");
            }
        }
    };
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.toggleAnimationState = function (value) {
        if (!this.animate) {
            return;
        }
        this.state = value ? 'active' : 'activeWithoutAnimation';
    };
    /**
     * @hidden
     */
    PanelBarItemComponent.prototype.toggleExpandedChildAnimations = function (value) {
        if (this.childrenItems) {
            this.childrenItems.forEach(function (child) {
                if (child.expanded) {
                    child.toggleAnimationState(value);
                    child.toggleExpandedChildAnimations(value);
                }
            });
        }
    };
    PanelBarItemComponent.prototype.onWrapperFocusChange = function (focused) {
        this.wrapperFocused = focused;
    };
    PanelBarItemComponent.decorators = [
        { type: Component, args: [{
                    animations: [
                        trigger('toggle', [
                            state('inactive', style({ display: 'none' })),
                            transition('* => active', [
                                style({ overflow: 'hidden', display: 'block', height: 0 }),
                                animate(200, style({ height: AUTO_STYLE }))
                            ]),
                            transition('active => *', [
                                style({ overflow: 'hidden', height: '*' }),
                                animate(200, style({ height: 0, display: 'none' }))
                            ])
                        ])
                    ],
                    exportAs: 'kendoPanelbarItem',
                    selector: "kendo-panelbar-item",
                    template: "<span\n                #header\n                [class.k-link]=\"true\"\n                [class.k-header]=\"!parent\"\n                [class.k-state-selected]=\"!disabled && selected\"\n                [class.k-state-focused]=\"!disabled && focused && wrapperFocused\"\n                (click)=\"onItemClick($event)\">\n            <span\n                *ngIf=\"icon || iconClass\"\n                class=\"k-icon\"\n                [ngClass]=\"iconClasses\">\n            </span>\n            <img\n                *ngIf=\"imageUrl\"\n                class=\"k-image\"\n                [src]=\"imageUrl\"\n                alt=\"\">\n            {{title}}\n            <ng-template [ngTemplateOutlet]=\"titleTemplate\"></ng-template>\n            <span *ngIf=\"hasChildItems || hasContent\"\n                [class.k-icon]=\"true\"\n                [class.k-i-arrow-n]=\"expanded\"\n                [class.k-panelbar-collapse]=\"expanded\"\n                [class.k-i-arrow-s]=\"!expanded\"\n                [class.k-panelbar-expand]=\"!expanded\">\n            </span>\n        </span>\n        <div #contentWrapper\n            *ngIf=\"keepContent || (!disabled && expanded && (hasChildItems || hasContent))\"\n            [@toggle]=\"state\"\n            [attr.role]=\"'group'\"\n            [attr.aria-hidden]=\"!disabled && !expanded\">\n            <div\n                *ngIf=\"hasChildItems && !items?.length\"\n                [style.overflow]=\"contentOverflow\"\n                [style.height]=\"contentHeight\"\n                class=\"k-panel k-group\">\n                    <ng-content select=\"kendo-panelbar-item\"></ng-content>\n            </div>\n            <div\n                *ngIf=\"hasContent && !content\"\n                [style.overflow]=\"contentOverflow\"\n                [style.height]=\"contentHeight\"\n                class=\"k-content\">\n                <ng-template\n                    [ngTemplateOutlet]=\"contentTemplate.first.templateRef\"\n                    [ngTemplateOutletContext]=\"{\n                        $implicit: {\n                            title: title,\n                            id: id,\n                            icon: icon,\n                            imageUrl: imageUrl,\n                            disabled: disabled,\n                            content: content\n                        }\n                    }\">\n                </ng-template>\n            </div>\n            <div *ngIf=\"hasItems\"\n                [style.overflow]=\"contentOverflow\"\n                [style.height]=\"contentHeight\"\n                class=\"k-panel k-group\">\n                <ng-container *ngFor=\"let item of items\">\n                    <kendo-panelbar-item *ngIf=\"!item.hidden\"\n                        [title]=\"item.title\"\n                        [id]=\"item.id\"\n                        [icon]=\"item.icon\"\n                        [iconClass]=\"item.iconClass\"\n                        [imageUrl]=\"item.imageUrl\"\n                        [selected]=\"!!item.selected\"\n                        [expanded]=\"!!item.expanded\"\n                        [disabled]=\"!!item.disabled\"\n                        [template]=\"template\"\n                        [items]=\"item.children\"\n                        [content]=\"item.content\">\n                    </kendo-panelbar-item>\n                </ng-container>\n            </div>\n            <div\n                *ngIf=\"content\"\n                [style.overflow]=\"contentOverflow\"\n                [style.height]=\"contentHeight\"\n                class=\"k-content\">\n                <ng-template\n                    [ngTemplateOutlet]=\"template\"\n                    [ngTemplateOutletContext]=\"{\n                        $implicit: {\n                            title: title,\n                            id: id,\n                            icon: icon,\n                            imageUrl: imageUrl,\n                            disabled: disabled,\n                            content: content\n                        }\n                    }\">\n                </ng-template>\n                <ng-template [ngIf]=\"!template\">{{content}}</ng-template>\n            </div>\n        </div>"
                },] },
    ];
    /** @nocollapse */
    PanelBarItemComponent.ctorParameters = function () { return [
        { type: PanelBarItemComponent, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] },
        { type: PanelBarService },
        { type: ElementRef }
    ]; };
    PanelBarItemComponent.propDecorators = {
        title: [{ type: Input }],
        id: [{ type: Input }],
        icon: [{ type: Input }],
        iconClass: [{ type: Input }],
        imageUrl: [{ type: Input }],
        disabled: [{ type: Input }],
        expanded: [{ type: Input }],
        selected: [{ type: Input }],
        content: [{ type: Input }],
        items: [{ type: Input }],
        template: [{ type: Input }],
        header: [{ type: ViewChild, args: ['header', {},] }],
        contentWrapper: [{ type: ViewChild, args: ['contentWrapper', {},] }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        titleAttribute: [{ type: HostBinding, args: ['attr.title',] }],
        kItemClass: [{ type: HostBinding, args: ['class.k-item',] }],
        kStateDefaultClass: [{ type: HostBinding, args: ['class.k-state-default',] }],
        kStateDisabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],
        kStateExpandedClass: [{ type: HostBinding, args: ['class.k-state-expanded',] }],
        itemId: [{ type: HostBinding, args: ['id',] }],
        ariaExpanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
        ariaSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }],
        ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],
        viewChildItems: [{ type: ViewChildren, args: [PanelBarItemComponent,] }],
        contentItems: [{ type: ContentChildren, args: [PanelBarItemComponent,] }],
        contentTemplate: [{ type: ContentChildren, args: [PanelBarContentDirective, { descendants: false },] }],
        titleTemplates: [{ type: ContentChildren, args: [PanelBarItemTitleDirective, { descendants: false },] }]
    };
    return PanelBarItemComponent;
}());

/**
 * Represents the template directive of the PanelBar which helps to customize the item content.
 */
var PanelBarItemTemplateDirective = /** @class */ (function () {
    function PanelBarItemTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    PanelBarItemTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoPanelBarItemTemplate]'
                },] },
    ];
    /** @nocollapse */
    PanelBarItemTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef, decorators: [{ type: Optional }] }
    ]; };
    return PanelBarItemTemplateDirective;
}());

var nextId$1 = 0;
var parsePanelBarItems = function (data) {
    return data.map(function (item) {
        if (!item.id) {
            item.id = "default-" + nextId$1++;
        }
        if (item.children) {
            item.children = parsePanelBarItems(item.children);
        }
        return item;
    });
};
var util = {
    parsePanelBarItems: parsePanelBarItems
};

/**
 * Represents the [Kendo UI PanelBar component for Angular]({% slug overview_panelbar %}).
 */
var PanelBarComponent = /** @class */ (function () {
    function PanelBarComponent(elementRef, eventService, localization) {
        var _this = this;
        this.localization = localization;
        /**
         * Sets the expand mode of the PanelBar through the `PanelBarExpandMode` enum ([see example]({% slug expandmodes_panelbar %})).
         *
         * The available modes are:
         * - `"single"`&mdash;Expands only one item at a time. Expanding an item collapses the item that was previously expanded.
         * - `"multiple"`&mdash;The default mode of the PanelBar.
         * Expands more than one item at a time. Items can also be toggled.
         * - `"full"`&mdash;Expands only one item at a time.
         * The expanded area occupies the entire height of the PanelBar. Requires you to set the `height` property.
         */
        this.expandMode = PanelBarExpandMode.Default;
        /**
         * Allows the PanelBar to modify the selected state of the items.
         */
        this.selectable = true;
        /**
         * Sets the animate state of the PanelBar ([see example]({% slug animations_panelbar %})).
         */
        this.animate = true;
        /**
         * Sets the height of the component when the `"full"` expand mode is used.
         * This option is ignored in the `"multiple"` and `"single"` expand modes.
         */
        this.height = "400px";
        /**
         * Fires each time the user interacts with a PanelBar item
         * ([see example]({% slug routing_panelbar %}#toc-getting-the-selected-item)).
         * The event data contains all items that are modified.
         */
        this.stateChange = new EventEmitter();
        this.tabIndex = 0;
        this.role = "tree";
        this.activeDescendant = "";
        this.isViewInit = true;
        this.focused = false;
        this._keepItemContent = false;
        this.updateChildrenHeight = function () {
            var childrenHeight = 0;
            var panelbarHeight = _this.elementRef.nativeElement.offsetHeight;
            var contentOverflow = _this.expandMode === PanelBarExpandMode.Full ? 'auto' : 'visible';
            _this.childrenItems.forEach(function (item) {
                childrenHeight += item.headerHeight();
            });
            _this.childrenItems.forEach(function (item) {
                item.contentHeight = PanelBarExpandMode.Full === _this.expandMode ? (panelbarHeight - childrenHeight) + "px" : 'auto';
                item.contentOverflow = contentOverflow;
            });
        };
        this.keyBindings = this.computedKeys;
        this.elementRef = elementRef;
        this.eventService = eventService;
        this.eventService.children$.subscribe(function (event) { return _this.onItemAction(event); });
    }
    Object.defineProperty(PanelBarComponent.prototype, "keepItemContent", {
        /**
         * When set to `true`, the PanelBar renders the content of all items and they are persisted in the DOM
         * ([see example]({% slug templates_panelbar %}#toc-collections)).
         * By default, this option is set to `false`.
         */
        get: function () {
            return this._keepItemContent;
        },
        set: function (keepItemContent) {
            this._keepItemContent = keepItemContent;
            this.eventService.onKeepContent(keepItemContent);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarComponent.prototype, "items", {
        get: function () {
            return this._items;
        },
        /**
         * Sets the items of the PanelBar as an array of `PanelBarItemModel` instances
         * ([see example]({% slug items_panelbar %})).
         */
        set: function (data) {
            if (data) {
                this._items = util.parsePanelBarItems(data);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarComponent.prototype, "hostHeight", {
        get: function () {
            return this.expandMode === PanelBarExpandMode.Full ? this.height : 'auto';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarComponent.prototype, "overflow", {
        get: function () {
            return this.expandMode === PanelBarExpandMode.Full ? "hidden" : "visible";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PanelBarComponent.prototype, "dir", {
        get: function () {
            return this.localization.rtl ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    PanelBarComponent.prototype.invertKeys = function (original, inverted) {
        return this.localization.rtl ? inverted : original;
    };
    Object.defineProperty(PanelBarComponent.prototype, "computedKeys", {
        get: function () {
            var _this = this;
            var _a;
            return _a = {}, _a[Keys.Space] = function () { return _this.selectFocusedItem(); }, _a[Keys.Enter] = function () { return _this.selectFocusedItem(); }, _a[Keys.ArrowUp] = function () { return _this.focusPreviousItem(); }, _a[this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight)] = function () { return _this.collapseItem(); }, _a[Keys.ArrowDown] = function () { return _this.focusNextItem(); }, _a[this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft)] = function () { return _this.expandItem(); }, _a[Keys.End] = function () { return _this.focusLastItem(); }, _a[Keys.Home] = function () { return _this.focusFirstItem(); }, _a;
        },
        enumerable: true,
        configurable: true
    });
    PanelBarComponent.prototype.ngOnDestroy = function () {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    };
    PanelBarComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.localizationChangeSubscription = this.localization
            .changes.subscribe(function () {
            return _this.keyBindings = _this.computedKeys;
        });
        this.eventService.animate = this.animate;
    };
    PanelBarComponent.prototype.ngAfterViewChecked = function () {
        var _this = this;
        if (this.items) {
            this.childrenItems = this.viewChildItems.toArray();
            this.allItems = this.viewItems;
        }
        else {
            this.childrenItems = this.contentChildItems.toArray();
            this.allItems = this.contentItems.toArray();
        }
        if (this.isViewInit && this.childrenItems.length) {
            this.isViewInit = false;
            setTimeout(function () { return _this.updateChildrenHeight(); });
        }
        this.validateConfiguration();
    };
    PanelBarComponent.prototype.ngOnChanges = function (changes) {
        if (changes['height'] || changes['expandMode'] || changes["items"]) { // tslint:disable-line
            if (this.childrenItems) {
                setTimeout(this.updateChildrenHeight);
            }
        }
        if (changes.animate) {
            this.eventService.animate = this.animate;
        }
    };
    Object.defineProperty(PanelBarComponent.prototype, "templateRef", {
        get: function () {
            return this.template ? this.template.templateRef : undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    PanelBarComponent.prototype.onComponentClick = function (event) {
        var itemClicked = this.visibleItems().some(function (item) {
            return item.header.nativeElement.contains(event.target);
        });
        if (!this.focused && itemClicked) {
            this.elementRef.nativeElement.focus();
        }
    };
    /**
     * @hidden
     */
    PanelBarComponent.prototype.onComponentFocus = function () {
        this.eventService.onFocus();
        this.focused = true;
        if (this.allItems.length > 0) {
            var visibleItems = this.visibleItems();
            var focusedItems = visibleItems.filter(function (item) { return item.focused; });
            if (!focusedItems.length && visibleItems.length > 0) {
                visibleItems[0].focused = true;
                this.activeDescendant = visibleItems[0].itemId;
            }
        }
    };
    /**
     * @hidden
     */
    PanelBarComponent.prototype.onComponentBlur = function () {
        this.eventService.onBlur();
        this.focused = false;
        this.activeDescendant = "";
    };
    /**
     * @hidden
     */
    PanelBarComponent.prototype.onComponentKeyDown = function (event) {
        if (event.target === this.elementRef.nativeElement) {
            if (event.keyCode === Keys.Space || event.keyCode === Keys.ArrowUp || event.keyCode === Keys.ArrowDown ||
                event.keyCode === Keys.ArrowLeft || event.keyCode === Keys.ArrowRight || event.keyCode === Keys.Home ||
                event.keyCode === Keys.End || event.keyCode === Keys.PageUp || event.keyCode === Keys.PageDown) {
                event.preventDefault();
            }
            var handler = this.keyBindings[event.keyCode];
            //TODO: check if next item is disabled and skip operation?
            if (handler) {
                handler();
            }
        }
    };
    Object.defineProperty(PanelBarComponent.prototype, "viewItems", {
        get: function () {
            var treeItems = [];
            this.viewChildItems.toArray().forEach(function (item) {
                treeItems.push(item);
                treeItems = treeItems.concat(item.subTreeViewItems());
            });
            return treeItems;
        },
        enumerable: true,
        configurable: true
    });
    PanelBarComponent.prototype.validateConfiguration = function () {
        if (isDevMode()) {
            if (this.items && (this.contentItems && this.contentItems.length > 0)) {
                throw new Error("Invalid configuration: mixed template components and items property.");
            }
        }
    };
    PanelBarComponent.prototype.onItemAction = function (item) {
        var _this = this;
        if (!item) {
            return;
        }
        var modifiedItems = new Array();
        this.allItems
            .forEach(function (currentItem) {
            var selectedState = currentItem === item;
            var focusedState = selectedState;
            selectedState = _this.selectable ? selectedState : currentItem.selected;
            if (currentItem.selected !== selectedState || currentItem.focused !== focusedState) {
                currentItem.selected = selectedState;
                currentItem.focused = focusedState;
                _this.activeDescendant = focusedState ? currentItem.itemId : "";
                modifiedItems.push(currentItem);
            }
        });
        if (this.expandMode === PanelBarExpandMode.Multiple) {
            if (item.hasChildItems || item.hasContent) {
                item.expanded = !item.expanded;
            }
            if (modifiedItems.indexOf(item) < 0) {
                modifiedItems.push(item);
            }
        }
        else {
            var siblings = item.parent ? item.parent.childrenItems : this.childrenItems;
            if (item.hasChildItems || item.hasContent) {
                siblings
                    .forEach(function (currentItem) {
                    var expandedState = currentItem === item;
                    if (currentItem.expanded !== expandedState) {
                        currentItem.expanded = expandedState;
                        if (modifiedItems.indexOf(currentItem) < 0) {
                            modifiedItems.push(currentItem);
                        }
                    }
                });
            }
        }
        if (modifiedItems.length > 0) {
            this.stateChange.emit(modifiedItems.map(function (currentItem) { return currentItem.serialize(); }));
        }
    };
    Object.defineProperty(PanelBarComponent.prototype, "hostClasses", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    PanelBarComponent.prototype.isVisible = function (item) {
        var visibleItems = this.visibleItems();
        return visibleItems.some(function (i) { return i === item; });
    };
    PanelBarComponent.prototype.getVisibleParent = function (item) {
        var visibleItems = this.visibleItems();
        if (!item.parent) {
            return item;
        }
        return visibleItems.some(function (i) { return i === item.parent; }) ? item.parent : this.getVisibleParent(item.parent);
    };
    PanelBarComponent.prototype.focusItem = function (action) {
        var visibleItems = this.visibleItems();
        var currentIndex = visibleItems.findIndex(function (item) { return item.focused; });
        var currentItem = visibleItems[currentIndex];
        var nextItem;
        if (currentIndex === -1) {
            var focusedItem = this.allItems.find(function (item) { return item.focused; });
            focusedItem.focused = false;
            currentItem = this.getVisibleParent(focusedItem);
            currentIndex = visibleItems.findIndex(function (item) { return item === currentItem; });
        }
        switch (action) {
            case "lastItem":
                nextItem = visibleItems[visibleItems.length - 1];
                break;
            case "firstItem":
                nextItem = visibleItems[0];
                break;
            case "nextItem":
                nextItem = visibleItems[currentIndex < visibleItems.length - 1 ? currentIndex + 1 : 0];
                break;
            case "previousItem":
                nextItem = visibleItems[currentIndex > 0 ? currentIndex - 1 : visibleItems.length - 1];
                break;
            default:
        }
        if (currentItem && nextItem && currentItem !== nextItem) {
            this.moveFocus(currentItem, nextItem);
        }
    };
    PanelBarComponent.prototype.moveFocus = function (from, to) {
        from.focused = false;
        to.focused = true;
        this.activeDescendant = to.itemId;
        var modifiedItems = new Array(from.serialize(), to.serialize());
        this.stateChange.emit(modifiedItems);
    };
    PanelBarComponent.prototype.focusLastItem = function () {
        this.focusItem("lastItem");
    };
    PanelBarComponent.prototype.focusFirstItem = function () {
        this.focusItem("firstItem");
    };
    PanelBarComponent.prototype.focusNextItem = function () {
        this.focusItem("nextItem");
    };
    PanelBarComponent.prototype.focusPreviousItem = function () {
        this.focusItem("previousItem");
    };
    PanelBarComponent.prototype.expandItem = function () {
        var currentItem = this.allItems.filter(function (item) { return item.focused; })[0];
        if (!this.isVisible(currentItem)) {
            currentItem.focused = false;
            currentItem = this.getVisibleParent(currentItem);
        }
        if (currentItem.hasChildItems || currentItem.hasContent) {
            if (!currentItem.expanded) {
                this.onItemAction(currentItem);
            }
            else if (currentItem.hasChildItems) {
                var firstChildIndex = currentItem.childrenItems.findIndex(function (item) { return !item.disabled; });
                if (firstChildIndex > -1) {
                    this.moveFocus(currentItem, currentItem.childrenItems[firstChildIndex]);
                }
            }
        }
    };
    PanelBarComponent.prototype.collapseItem = function () {
        var currentItem = this.allItems.filter(function (item) { return item.focused; })[0];
        if (currentItem.expanded) {
            this.onItemAction(currentItem);
        }
        else if (currentItem.parent) {
            this.moveFocus(currentItem, currentItem.parent);
        }
    };
    PanelBarComponent.prototype.selectFocusedItem = function () {
        var focusedItem = this.allItems.filter(function (item) { return item.focused; })[0];
        if (!this.isVisible(focusedItem)) {
            focusedItem.focused = false;
            focusedItem = this.getVisibleParent(focusedItem);
        }
        if (focusedItem) {
            focusedItem.onItemAction();
        }
    };
    PanelBarComponent.prototype.visibleItems = function () {
        return this.flatVisibleItems(this.childrenItems);
    };
    PanelBarComponent.prototype.flatVisibleItems = function (listOfItems, flattedItems) {
        var _this = this;
        if (listOfItems === void 0) { listOfItems = new Array(); }
        if (flattedItems === void 0) { flattedItems = new Array(); }
        listOfItems.forEach(function (item) {
            if (!item.disabled) {
                flattedItems.push(item);
                if (item.expanded && item.hasChildItems) {
                    _this.flatVisibleItems(item.childrenItems, flattedItems);
                }
            }
        });
        return flattedItems;
    };
    PanelBarComponent.decorators = [
        { type: Component, args: [{
                    exportAs: 'kendoPanelbar',
                    providers: [
                        PanelBarService,
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.panelbar'
                        }
                    ],
                    selector: 'kendo-panelbar',
                    template: "\n        <ng-content *ngIf=\"contentChildItems && !items\" select=\"kendo-panelbar-item\"></ng-content>\n        <ng-template [ngIf]=\"items?.length\">\n            <ng-container *ngFor=\"let item of items\">\n                <kendo-panelbar-item *ngIf=\"!item.hidden\"\n                     [title]=\"item.title\"\n                     [id]=\"item.id\"\n                     [icon]=\"item.icon\"\n                     [iconClass]=\"item.iconClass\"\n                     [imageUrl]=\"item.imageUrl\"\n                     [selected]=\"!!item.selected\"\n                     [expanded]=\"!!item.expanded\"\n                     [disabled]=\"!!item.disabled\"\n                     [template]=\"templateRef\"\n                     [items]=\"item.children\"\n                     [content]=\"item.content\"\n                >\n                </kendo-panelbar-item>\n            </ng-container>\n        </ng-template>\n    "
                },] },
    ];
    /** @nocollapse */
    PanelBarComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: PanelBarService },
        { type: LocalizationService }
    ]; };
    PanelBarComponent.propDecorators = {
        expandMode: [{ type: Input }],
        selectable: [{ type: Input }],
        animate: [{ type: Input }],
        height: [{ type: Input }],
        keepItemContent: [{ type: Input }],
        items: [{ type: Input }],
        stateChange: [{ type: Output }],
        tabIndex: [{ type: HostBinding, args: ['attr.tabIndex',] }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        activeDescendant: [{ type: HostBinding, args: ['attr.aria-activedescendant',] }],
        hostHeight: [{ type: HostBinding, args: ['style.height',] }],
        overflow: [{ type: HostBinding, args: ['style.overflow',] }],
        dir: [{ type: HostBinding, args: ['attr.dir',] }],
        template: [{ type: ContentChild, args: [PanelBarItemTemplateDirective,] }],
        contentItems: [{ type: ContentChildren, args: [PanelBarItemComponent, { descendants: true },] }],
        contentChildItems: [{ type: ContentChildren, args: [PanelBarItemComponent,] }],
        viewChildItems: [{ type: ViewChildren, args: [PanelBarItemComponent,] }],
        onComponentClick: [{ type: HostListener, args: ['click', ['$event'],] }],
        onComponentFocus: [{ type: HostListener, args: ['focus',] }],
        onComponentBlur: [{ type: HostListener, args: ['blur',] }],
        onComponentKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
        hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-panelbar',] }]
    };
    return PanelBarComponent;
}());

/**
 * Represents the pane component of the Splitter.
 */
var SplitterPaneComponent = /** @class */ (function () {
    function SplitterPaneComponent(element, renderer, cdr) {
        this.element = element;
        this.renderer = renderer;
        this.cdr = cdr;
        /**
         * Specifies if the user is allowed to resize the pane and provide space for other panes.
         */
        this.resizable = true;
        /**
         * Specifies if the user is allowed to hide the pane and provide space for other panes.
         */
        this.collapsible = false;
        /**
         * Specifies if overflowing content is scrollable or hidden.
         */
        this.scrollable = true;
        /**
         * Specifies if the pane is initially collapsed.
         */
        this.collapsed = false;
        /**
         * @hidden
         */
        this.orientation = 'horizontal';
        /**
         * @hidden
         */
        this.containsSplitter = false;
        /**
         * @hidden
         */
        this.overlayContent = false;
        /**
         * Fires each time the user resizes the Splitter pane.
         * The event data contains the new pane size.
         * Allows a two-way binding of the pane `size` property.
         */
        this.sizeChange = new EventEmitter();
        /**
         * Fires each time the `collapsed` property changes.
         * The event data contains the new property state.
         * Allows a two-way binding of the `collapsed` pane property.
         */
        this.collapsedChange = new EventEmitter();
        this.hostClass = true;
        /**
         * @hidden
         */
        this.forceExpand = false;
    }
    Object.defineProperty(SplitterPaneComponent.prototype, "order", {
        get: function () {
            return this._order;
        },
        /**
         * @hidden
         */
        set: function (paneOrder) {
            this._order = paneOrder;
            this.setOrderStyles();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "size", {
        get: function () {
            return this._size;
        },
        /**
         * Sets the initial size of the pane.
         * Has to be between the `min` and `max` properties.
         */
        set: function (newSize) {
            this._size = newSize;
            var element = this.element.nativeElement;
            this.renderer.setStyle(element, '-ms-flex-preferred-size', newSize);
            this.renderer.setStyle(element, 'flex-basis', newSize);
            if (this.staticPaneClass) {
                this.renderer.addClass(element, 'k-pane-static');
            }
            else {
                this.renderer.removeClass(element, 'k-pane-static');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "isHidden", {
        get: function () {
            return this.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "styleDisplayFlex", {
        get: function () {
            return this.containsSplitter;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "staticPaneClass", {
        get: function () {
            if (this.forceExpand) {
                return false;
            }
            return !this.resizable && !this.collapsible || this.fixedSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "scrollablePaneClass", {
        get: function () {
            return this.scrollable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "fixedSize", {
        get: function () {
            return this.size && this.size.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    SplitterPaneComponent.prototype.ngAfterViewChecked = function () {
        var element = this.element.nativeElement;
        if (this.isHidden) {
            this.renderer.addClass(element, 'k-state-hidden');
            this.renderer.addClass(element, 'hidden');
        }
        else {
            this.renderer.removeClass(element, 'k-state-hidden');
            this.renderer.removeClass(element, 'hidden');
        }
    };
    Object.defineProperty(SplitterPaneComponent.prototype, "computedSize", {
        /**
         * @hidden
         */
        get: function () {
            if (this.orientation === 'vertical') {
                return this.element.nativeElement.offsetHeight;
            }
            else {
                return this.element.nativeElement.offsetWidth;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    SplitterPaneComponent.prototype.toggleOverlay = function (show) {
        this.overlayContent = show;
        this.cdr.detectChanges();
    };
    /**
     * @hidden
     */
    SplitterPaneComponent.prototype.detectChanges = function () {
        this.cdr.detectChanges();
    };
    /**
     * @hidden
     */
    SplitterPaneComponent.prototype.setOrderStyles = function () {
        var element = this.element.nativeElement;
        this.renderer.setStyle(element, '-ms-flex-order', this.order);
        this.renderer.setStyle(element, 'order', this.order);
    };
    SplitterPaneComponent.decorators = [
        { type: Component, args: [{
                    exportAs: 'kendoSplitterPane',
                    selector: 'kendo-splitter-pane',
                    template: "\n        <ng-container *ngIf=\"!collapsed\"><ng-content></ng-content></ng-container>\n        <div *ngIf=\"overlayContent\" class=\"k-splitter-overlay k-overlay\"></div>\n    "
                },] },
    ];
    /** @nocollapse */
    SplitterPaneComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: ChangeDetectorRef }
    ]; };
    SplitterPaneComponent.propDecorators = {
        order: [{ type: Input }],
        size: [{ type: Input }],
        min: [{ type: Input }],
        max: [{ type: Input }],
        resizable: [{ type: Input }],
        collapsible: [{ type: Input }],
        scrollable: [{ type: Input }],
        collapsed: [{ type: Input }],
        orientation: [{ type: Input }],
        containsSplitter: [{ type: Input }],
        overlayContent: [{ type: Input }],
        sizeChange: [{ type: Output }],
        collapsedChange: [{ type: Output }],
        styleDisplayFlex: [{ type: HostBinding, args: ['class.k-pane-flex',] }],
        hostClass: [{ type: HostBinding, args: ['class.k-pane',] }],
        staticPaneClass: [{ type: HostBinding, args: ['class.k-pane-static',] }],
        scrollablePaneClass: [{ type: HostBinding, args: ['class.k-scrollable',] }]
    };
    return SplitterPaneComponent;
}());

var SIZING_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/layout/splitter/panes/#toc-size';
/**
 * @hidden
 */
var SplitterService = /** @class */ (function () {
    function SplitterService(zone) {
        this.zone = zone;
        this.layoutChange = new EventEmitter();
        this.containerSize = function () { };
    }
    SplitterService.prototype.tryToggle = function (paneIndex) {
        var pane = this.pane(paneIndex);
        if (pane.collapsible) {
            pane.collapsed = !pane.collapsed;
            pane.collapsedChange.emit(pane.collapsed);
            this.emit(this.layoutChange, {});
            if (pane.collapsed) {
                pane.detectChanges();
            }
        }
        var notCollapsed = this.panes.filter(function (p) { return !p.collapsed; });
        var allHaveFixedSize = notCollapsed.every(function (p) { return p.fixedSize; });
        notCollapsed[notCollapsed.length - 1].forceExpand = allHaveFixedSize ? true : false;
        return pane.collapsible;
    };
    SplitterService.prototype.toggleContentOverlay = function (index, show) {
        this.pane(index).toggleOverlay(show);
        this.pane(index + 1).toggleOverlay(show);
    };
    SplitterService.prototype.dragState = function (splitbarIndex) {
        var _this = this;
        var prev = this.pane(splitbarIndex);
        var next = this.pane(splitbarIndex + 1);
        var total = prev.computedSize + next.computedSize;
        var px = function (s) { return _this.toPixels(s); };
        return {
            prev: {
                index: splitbarIndex,
                initialSize: prev.computedSize,
                min: px(prev.min) || total - px(next.max) || 0,
                max: px(prev.max) || total - px(next.min) || total
            },
            next: {
                index: splitbarIndex + 1,
                initialSize: next.computedSize,
                min: px(next.min) || total - px(prev.max) || 0,
                max: px(next.max) || total - px(prev.min) || total
            }
        };
    };
    SplitterService.prototype.setSize = function (state$$1, delta) {
        var _this = this;
        var clamp = function (min, max, v) { return Math.min(max, Math.max(min, v)); };
        var resize = function (paneState, change) {
            var pane = _this.pane(paneState.index);
            var splitterSize = _this.containerSize();
            var newSize = clamp(paneState.min, paneState.max, paneState.initialSize + change);
            var size = "";
            if (_this.isPercent(pane.size)) {
                size = (100 * newSize / splitterSize) + "%";
            }
            else {
                size = newSize + "px";
            }
            pane.size = size;
            _this.emit(pane.sizeChange, size);
        };
        var prev = this.pane(state$$1.prev.index);
        var next = this.pane(state$$1.next.index);
        // determine which pane to resize
        if (prev.fixedSize && next.fixedSize) {
            // resizing both panes
            resize(state$$1.prev, delta);
            resize(state$$1.next, -delta);
        }
        else if (next.collapsible || next.fixedSize) {
            // resizing next
            resize(state$$1.next, -delta);
        }
        else {
            // resizing prev
            resize(state$$1.prev, delta);
        }
        this.emit(this.layoutChange, {});
    };
    SplitterService.prototype.isDraggable = function (splitBarIndex) {
        var prev = this.pane(splitBarIndex);
        var next = this.pane(splitBarIndex + 1);
        var betweenResizablePanes = prev.resizable && next.resizable;
        var nearCollapsedPane = prev.collapsed || next.collapsed;
        return betweenResizablePanes && !nearCollapsedPane;
    };
    SplitterService.prototype.isStatic = function (splitBarIndex) {
        var prev = this.pane(splitBarIndex);
        var next = this.pane(splitBarIndex + 1);
        var betweenResizablePanes = prev.resizable && next.resizable;
        var nearCollapsiblePane = prev.collapsible || next.collapsible;
        return !betweenResizablePanes && !nearCollapsiblePane;
    };
    SplitterService.prototype.pane = function (index) {
        if (!this.panes) {
            throw new Error("Panes not initialized");
        }
        if (index < 0 || index >= this.panes.length) {
            throw new Error("Index out of range");
        }
        return this.panes[index];
    };
    SplitterService.prototype.configure = function (_a) {
        var panes = _a.panes, orientation = _a.orientation, containerSize = _a.containerSize;
        this.panes = panes;
        this.panes.forEach(function (pane, index) {
            pane.order = index * 2;
            pane.orientation = orientation;
        });
        if (isDevMode()) {
            var allFixed = panes.length && !panes.some(function (pane) { return !pane.fixedSize; });
            if (allFixed) {
                throw new Error("\n                    The Splitter should have at least one pane without a set size.\n                    See " + SIZING_DOC_LINK + " for more information.\n                ");
            }
        }
        this.containerSize = containerSize;
    };
    SplitterService.prototype.isPercent = function (size) {
        return /%$/.test(size);
    };
    SplitterService.prototype.toPixels = function (size) {
        var result = parseFloat(size);
        if (this.isPercent(size)) {
            result = (this.containerSize() * result / 100);
        }
        return result;
    };
    SplitterService.prototype.emit = function (emitter, args) {
        if (emitter.observers.length) {
            this.zone.run(function () { return emitter.emit(args); });
        }
    };
    SplitterService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    SplitterService.ctorParameters = function () { return [
        { type: NgZone }
    ]; };
    return SplitterService;
}());

/**
 * Represents the [Kendo UI Splitter component for Angular]({% slug overview_splitter %}).
 *
 * ```ts-preview
 *
 *  @Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-splitter style="height: 280px;">
 *
 *          <kendo-splitter-pane [collapsible]="true" size="30%">
 *            <h3>Inner splitter / left pane</h3>
 *            <p>Resizable and collapsible.</p>
 *          </kendo-splitter-pane>
 *
 *          <kendo-splitter-pane>
 *            <h3>Inner splitter / center pane</h3>
 *            <p>Resizable only.</p>
 *          </kendo-splitter-pane>
 *
 *          <kendo-splitter-pane [collapsible]="true" size="30%">
 *            <h3>Inner splitter / right pane</h3>
 *            <p>Resizable and collapsible.</p>
 *          </kendo-splitter-pane>
 *
 *        </kendo-splitter>
 *      `,
 *    styles: [ `
 *        h3 { font-size: 1.2em; }
 *        h3, p { margin: 10px; padding: 0; }
 *    ` ]
 *  })
 *  class AppComponent {}
 * ```
 */
var SplitterComponent = /** @class */ (function () {
    function SplitterComponent(element, splitterService, localization, enclosingPane) {
        this.element = element;
        this.splitterService = splitterService;
        this.localization = localization;
        /**
         * Specifies the orientation of the panes within the Splitter.
         * Panes in a horizontal Splitter are placed horizontally.
         * Panes in a vertical Splitter are placed vertically.
         */
        this.orientation = 'horizontal';
        this.ariaRole = 'splitter';
        if (enclosingPane) {
            enclosingPane.containsSplitter = true;
        }
        // the handler only runs in NgZone if there are bound handlers
        // this line merges both streams
        this.layoutChange = this.splitterService.layoutChange;
        this.configure = this.configure.bind(this);
    }
    Object.defineProperty(SplitterComponent.prototype, "hostClasses", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterComponent.prototype, "horizontalHostClasses", {
        get: function () {
            return this.orientation === 'horizontal';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterComponent.prototype, "verticalHostClasses", {
        get: function () {
            return this.orientation === 'vertical';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterComponent.prototype, "dir", {
        get: function () {
            return this.direction;
        },
        enumerable: true,
        configurable: true
    });
    SplitterComponent.prototype.ngAfterContentInit = function () {
        this.reconfigure();
    };
    SplitterComponent.prototype.ngOnChanges = function (changes) {
        if (changes.orientation && !changes.orientation.isFirstChange()) {
            this.reconfigure();
        }
    };
    SplitterComponent.prototype.ngOnDestroy = function () {
        this.unsubscribeChanges();
    };
    SplitterComponent.prototype.reconfigure = function () {
        this.unsubscribeChanges();
        this.configure();
        this.paneChangesSubscription = this.panes.changes.subscribe(this.configure);
    };
    SplitterComponent.prototype.unsubscribeChanges = function () {
        if (this.paneChangesSubscription) {
            this.paneChangesSubscription.unsubscribe();
            this.paneChangesSubscription = null;
        }
    };
    SplitterComponent.prototype.configure = function () {
        var _this = this;
        this.splitterService.configure({
            panes: this.panes.toArray(),
            orientation: this.orientation,
            containerSize: function () {
                if (_this.orientation === 'vertical') {
                    return _this.element.nativeElement.clientHeight;
                }
                else {
                    return _this.element.nativeElement.clientWidth;
                }
            }
        });
    };
    Object.defineProperty(SplitterComponent.prototype, "direction", {
        get: function () {
            return this.localization.rtl ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    SplitterComponent.decorators = [
        { type: Component, args: [{
                    exportAs: 'kendoSplitter',
                    selector: 'kendo-splitter',
                    providers: [
                        SplitterService,
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.spliter'
                        }
                    ],
                    template: "\n      <ng-content select=\"kendo-splitter-pane\"></ng-content>\n      <ng-container *ngFor=\"\n        let pane of panes;\n        let index = index;\n        let last = last;\n      \">\n        <kendo-splitter-bar\n          kendoDraggable\n          *ngIf=\"!last\"\n          [index]=\"index\"\n          [orientation]=\"orientation\">\n        </kendo-splitter-bar>\n      </ng-container>\n    "
                },] },
    ];
    /** @nocollapse */
    SplitterComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: SplitterService },
        { type: LocalizationService },
        { type: SplitterPaneComponent, decorators: [{ type: Optional }, { type: Host }, { type: Inject, args: [SplitterPaneComponent,] }] }
    ]; };
    SplitterComponent.propDecorators = {
        orientation: [{ type: Input }],
        layoutChange: [{ type: Output }],
        hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-splitter',] }, { type: HostBinding, args: ['class.k-splitter-flex',] }],
        horizontalHostClasses: [{ type: HostBinding, args: ['class.k-splitter-horizontal',] }],
        verticalHostClasses: [{ type: HostBinding, args: ['class.k-splitter-vertical',] }],
        dir: [{ type: HostBinding, args: ['attr.dir',] }],
        ariaRole: [{ type: HostBinding, args: ['attr.role',] }],
        panes: [{ type: ContentChildren, args: [SplitterPaneComponent,] }]
    };
    return SplitterComponent;
}());

/**
 * Represents the content template of the Kendo UI TabStrip.
 * To define the template, nest a `<ng-template>` tag with the `kendoTabContent` inside the component tag.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-tabstrip [ngStyle]="{'width': '400px'}" [animate]="true">
 *           <kendo-tabstrip-tab [title]="'Paris'" [selected]="true">
 *             <ng-template kendoTabContent>
 *               <h3>Content 1</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *
 *           <kendo-tabstrip-tab [title]="'Sofia'">
 *             <ng-template kendoTabContent>
 *               <h3>Content 2</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *         </kendo-tabstrip>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
var TabContentDirective = /** @class */ (function () {
    function TabContentDirective(templateRef) {
        this.templateRef = templateRef;
    }
    TabContentDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoTabContent]'
                },] },
    ];
    /** @nocollapse */
    TabContentDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return TabContentDirective;
}());

/**
 * Represents the title template of the Kendo UI TabStrip.
 * To define the template, nest a `<ng-template>` tag with the `kendoTabTitle` directive inside the component tag.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-tabstrip [ngStyle]="{'width': '400px'}" [animate]="true">
 *           <kendo-tabstrip-tab [title]="'Paris'" [selected]="true">
 *             <ng-template kendoTabTitle>
 *               Title
 *             </ng-template>
 *             <ng-template kendoTabContent>
 *               <h3>Content 1</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *
 *           <kendo-tabstrip-tab [title]="'Sofia'">
 *             <ng-template kendoTabContent>
 *               <h3>Content 2</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *         </kendo-tabstrip>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
var TabTitleDirective = /** @class */ (function () {
    function TabTitleDirective(templateRef) {
        this.templateRef = templateRef;
    }
    TabTitleDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoTabTitle]'
                },] },
    ];
    /** @nocollapse */
    TabTitleDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return TabTitleDirective;
}());

/**
 * Represents the tab component of the TabStrip.
 */
var TabStripTabComponent = /** @class */ (function () {
    function TabStripTabComponent() {
        this.active = false;
        this._tabContent = new QueryList();
    }
    Object.defineProperty(TabStripTabComponent.prototype, "tabContent", {
        get: function () {
            return this._tabContent.first;
        },
        enumerable: true,
        configurable: true
    });
    TabStripTabComponent.prototype.ngAfterContentInit = function () {
        this.active = this.selected;
    };
    TabStripTabComponent.prototype.ngOnChanges = function (changes) {
        if (changes['selected'] && !changes['selected'].isFirstChange()) { // tslint:disable-line
            this.active = this.selected;
        }
    };
    TabStripTabComponent.decorators = [
        { type: Component, args: [{
                    exportAs: 'kendoTabStripTab',
                    selector: 'kendo-tabstrip-tab',
                    template: ""
                },] },
    ];
    TabStripTabComponent.propDecorators = {
        title: [{ type: Input }],
        disabled: [{ type: Input }],
        cssClass: [{ type: Input }],
        selected: [{ type: Input }],
        _tabContent: [{ type: ContentChildren, args: [TabContentDirective,] }],
        tabTitle: [{ type: ContentChild, args: [TabTitleDirective,] }]
    };
    return TabStripTabComponent;
}());

/**
 * @hidden
 */
var PreventableEvent = /** @class */ (function () {
    /**
     * @hidden
     */
    function PreventableEvent(args) {
        this.prevented = false;
        Object.assign(this, args);
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses
     * the built-in behavior that follows the event.
     */
    PreventableEvent.prototype.preventDefault = function () {
        this.prevented = true;
    };
    /**
     * Returns `true` if the event was prevented
     * by any of its subscribers.
     *
     * @returns `true` if the default action was prevented.
     * Otherwise, returns `false`.
     */
    PreventableEvent.prototype.isDefaultPrevented = function () {
        return this.prevented;
    };
    return PreventableEvent;
}());

/**
 * Arguments for the `select` event of the TabStrip.
 * The `select` event fires when a tab is selected (clicked).
 */
var SelectEvent = /** @class */ (function (_super) {
    __extends(SelectEvent, _super);
    /**
     * Constructs the event arguments for the `select` event.
     * @param index - The index of the selected tab.
     * @param title - The title of the selected tab.
     */
    function SelectEvent(index, title) {
        var _this = _super.call(this) || this;
        _this.index = index;
        _this.title = title;
        return _this;
    }
    return SelectEvent;
}(PreventableEvent));

var isPresent$1 = function (value) { return !(value === undefined || value === null); };
/**
 * Represents the [Kendo UI TabStrip component for Angular]({% slug overview_tabstrip %}).
 */
var TabStripComponent = /** @class */ (function () {
    function TabStripComponent(localization, renderer, wrapper) {
        this.localization = localization;
        this.renderer = renderer;
        this.wrapper = wrapper;
        /**
         * Enables the tab animation.
         */
        this.animate = true;
        /**
         * Sets the position of the tabs. Defaults to `top`.
         */
        this.tabPosition = 'top';
        /**
         * When set to `true`, the component renders all tabs and they are persisted in the DOM.
         * By default, `keepTabContent` is `false`.
         */
        this.keepTabContent = false;
        /**
         * Fires each time the user selects a tab ([see example]({% slug overview_tabstrip %}#toc-basic-usage)).
         * The event data contains the index of the selected tab and its title.
         */
        this.tabSelect = new EventEmitter();
        this.hostClasses = true;
        /**
         * @hidden
         */
        this._animate = false;
        this.keyBindings = this.computedKeys;
    }
    Object.defineProperty(TabStripComponent.prototype, "height", {
        get: function () {
            return this._height;
        },
        /**
         * Sets the height of the TabStrip.
         */
        set: function (value) {
            this._height = value;
            this.renderer.setStyle(this.wrapper.nativeElement, 'height', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "tabsAtTop", {
        get: function () {
            return this.tabPosition === 'top';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "tabsAtRight", {
        get: function () {
            return this.tabPosition === 'right';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "tabsAtBottom", {
        get: function () {
            return this.tabPosition === 'bottom';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "tabsAtLeft", {
        get: function () {
            return this.tabPosition === 'left';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "dir", {
        get: function () {
            return this.localization.rtl ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "activeDescendantId", {
        get: function () {
            if (isPresent$1(this.selectedTabId)) {
                return this.tabId(this.selectedTabId);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    TabStripComponent.prototype.contentClass = function (active) {
        var visible = !this.keepTabContent || active;
        return visible ? 'k-content k-state-active' : 'k-content';
    };
    Object.defineProperty(TabStripComponent.prototype, "computedKeys", {
        get: function () {
            var _this = this;
            var _a;
            return _a = {}, _a[this.invertKeys(Keys.ArrowLeft, Keys.ArrowRight)] = function (selectedIndex) { return _this.prevNavigatableIndex(selectedIndex); }, _a[this.invertKeys(Keys.ArrowRight, Keys.ArrowLeft)] = function (selectedIndex) { return _this.nextNavigatableIndex(selectedIndex); }, _a[this.invertKeys(Keys.ArrowDown, Keys.ArrowUp)] = function (selectedIndex) { return _this.nextNavigatableIndex(selectedIndex); }, _a[this.invertKeys(Keys.ArrowUp, Keys.ArrowDown)] = function (selectedIndex) { return _this.prevNavigatableIndex(selectedIndex); }, _a[Keys.Home] = function () { return _this.firstNavigatableIndex(); }, _a[Keys.End] = function () { return _this.lastNavigatableIndex(); }, _a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabStripComponent.prototype, "tabsAlignment", {
        /**
         * @hidden
         */
        get: function () {
            return {
                start: 'flex-start',
                end: 'flex-end',
                center: 'center',
                justify: 'space-between'
            }[this.tabAlignment];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    TabStripComponent.prototype.invertKeys = function (original, inverted) {
        return this.localization.rtl ? inverted : original;
    };
    /**
     * @hidden
     */
    TabStripComponent.prototype.onKeyDown = function (event) {
        if (event.currentTarget !== this.tablist.nativeElement) {
            return;
        }
        var isHorizontal = this.tabPosition === 'top' || this.tabPosition === 'bottom';
        var isArrowUp = event.keyCode === Keys.ArrowUp;
        var isArrowDown = event.keyCode === Keys.ArrowDown;
        var isArrowLeft = event.keyCode === Keys.ArrowLeft;
        var isArrowRight = event.keyCode === Keys.ArrowRight;
        if (isHorizontal && (isArrowUp || isArrowDown)) {
            return;
        }
        if (!isHorizontal && (isArrowLeft || isArrowRight)) {
            return;
        }
        if (event.keyCode === Keys.Space || isArrowUp || isArrowDown || isArrowLeft || isArrowRight || event.keyCode === Keys.Home ||
            event.keyCode === Keys.End || event.keyCode === Keys.PageUp || event.keyCode === Keys.PageDown) {
            event.preventDefault();
        }
        var selectedIndex = this.tabs.toArray().findIndex(function (tab) { return tab.active && !tab.disabled; });
        if (selectedIndex === -1) {
            this.selectTab(this.firstNavigatableIndex());
        }
        else {
            var getTabIndex = this.keyBindings[event.keyCode];
            if (getTabIndex) {
                var nextIndex = getTabIndex(selectedIndex);
                if (selectedIndex !== nextIndex) {
                    this.selectTab(getTabIndex(selectedIndex));
                }
            }
        }
    };
    /**
     * @hidden
     */
    TabStripComponent.prototype.tabPanelId = function (id) {
        return 'k-tabstrip-tabpanel-' + id;
    };
    /**
     * @hidden
     */
    TabStripComponent.prototype.tabId = function (id) {
        return 'k-tabstrip-tab-' + id;
    };
    /**
     * Allows the user to select a tab programmatically.
     * @param {number} index - The index of the tab that will be selected.
     */
    TabStripComponent.prototype.selectTab = function (index) {
        var tab = this.tabs.toArray()[index];
        if (!tab || Boolean(tab.disabled)) {
            return;
        }
        this.emitEvent(tab, index);
        this.selectedTabId = index;
    };
    TabStripComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.localizationChangeSubscription = this.localization
            .changes.subscribe(function () {
            return _this.keyBindings = _this.computedKeys;
        });
    };
    TabStripComponent.prototype.ngOnDestroy = function () {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    };
    TabStripComponent.prototype.firstNavigatableIndex = function () {
        var tabs = this.tabs.toArray();
        for (var i = 0; i < tabs.length; i++) {
            if (!tabs[i].disabled) {
                return i;
            }
        }
    };
    TabStripComponent.prototype.lastNavigatableIndex = function () {
        var tabs = this.tabs.toArray();
        for (var i = tabs.length - 1; i > 0; i--) {
            if (!tabs[i].disabled) {
                return i;
            }
        }
    };
    TabStripComponent.prototype.prevNavigatableIndex = function (selectedIndex) {
        if (selectedIndex - 1 < 0) {
            return this.lastNavigatableIndex();
        }
        var tabs = this.tabs.toArray();
        for (var i = selectedIndex - 1; i > -1; i--) {
            if (!tabs[i].disabled) {
                return i;
            }
            if (i === 0) {
                return this.lastNavigatableIndex();
            }
        }
        return selectedIndex;
    };
    TabStripComponent.prototype.nextNavigatableIndex = function (selectedIndex) {
        if (selectedIndex + 1 >= this.tabs.length) {
            return this.firstNavigatableIndex();
        }
        var tabs = this.tabs.toArray();
        for (var i = selectedIndex + 1; i < tabs.length; i++) {
            if (!tabs[i].disabled) {
                return i;
            }
            if (i + 1 === tabs.length) {
                return this.firstNavigatableIndex();
            }
        }
    };
    TabStripComponent.prototype.emitEvent = function (tab, selectedIndex) {
        var selectArgs = new SelectEvent(selectedIndex, tab.title);
        this.tabSelect.emit(selectArgs);
        if (!selectArgs.isDefaultPrevented() && !tab.active) {
            this._animate = this.animate;
            this.deactivateAll();
            tab.active = true;
        }
    };
    TabStripComponent.prototype.deactivateAll = function () {
        this.tabs.forEach(function (tab) {
            tab.active = false;
        });
    };
    TabStripComponent.decorators = [
        { type: Component, args: [{
                    animations: [
                        trigger('state', [
                            state('active', style({ opacity: 1 })),
                            transition('* => active', [
                                style({ opacity: 0 }),
                                animate('400ms ease-in')
                            ])
                        ])
                    ],
                    providers: [
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.tabstrip'
                        }
                    ],
                    exportAs: 'kendoTabStrip',
                    selector: 'kendo-tabstrip',
                    template: "\n        <ng-container *ngIf=\"!tabsAtBottom\">\n            <ng-container *ngTemplateOutlet=\"heading\">\n            </ng-container>\n            <ng-container *ngTemplateOutlet=\"content\">\n            </ng-container>\n        </ng-container>\n\n        <ng-container *ngIf=\"tabsAtBottom\">\n            <ng-container *ngTemplateOutlet=\"content\">\n            </ng-container>\n            <ng-container *ngTemplateOutlet=\"heading\">\n            </ng-container>\n        </ng-container>\n\n        <ng-template #heading>\n            <ul\n                class=\"k-reset k-tabstrip-items\"\n                [style.justifyContent]=\"tabsAlignment\"\n                role=\"tablist\"\n                (keydown)=\"onKeyDown($event)\"\n                [tabIndex]=\"0\"\n                #tablist\n            >\n                <li *ngFor=\"let tab of tabs; let i = index;\" (click)=\"selectTab(i)\"\n                    role=\"tab\"\n                    [id]=\"tabId(i)\"\n                    [ngClass]=\"tab.cssClass\"\n                    [class.k-item]=\"true\"\n                    [class.k-state-default]=\"true\"\n                    [class.k-state-active]=\"tab.active\"\n                    [class.k-state-disabled]=\"tab.disabled\"\n                    [attr.aria-selected]=\"tab.active\"\n                    [attr.aria-controls]=\"tabPanelId(i)\"\n                    [attr.aria-disabled]=\"tab.disabled\"\n                ><span class=\"k-link\">{{ tab.title }}<ng-template [ngTemplateOutlet]=\"tab.tabTitle?.templateRef\"></ng-template></span></li>\n            </ul>\n        </ng-template>\n        <ng-template #content>\n            <ng-template ngFor let-tab [ngForOf]=\"tabs\" let-i=\"index\">\n                <div\n                    [@state]=\"tab.active && _animate ? 'active' : 'inactive'\"\n                    *ngIf=\"tab.active || keepTabContent\"\n                    [ngClass]=\"contentClass(tab.active)\"\n                    role=\"tabpanel\"\n                    [id]=\"tabPanelId(i)\"\n                    [attr.aria-hidden]=\"!tab.active\"\n                    [attr.aria-expanded]=\"tab.active\"\n                    [attr.aria-labelledby]=\"tabId(i)\"\n                    [attr.aria-disabled]=\"tab.disabled\"\n                >\n                    <ng-template [ngTemplateOutlet]=\"tab.tabContent?.templateRef\"></ng-template>\n                </div>\n            </ng-template>\n        </ng-template>\n    "
                },] },
    ];
    /** @nocollapse */
    TabStripComponent.ctorParameters = function () { return [
        { type: LocalizationService },
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    TabStripComponent.propDecorators = {
        height: [{ type: Input }],
        animate: [{ type: Input }],
        tabAlignment: [{ type: Input }],
        tabPosition: [{ type: Input }],
        keepTabContent: [{ type: Input }],
        tablist: [{ type: ViewChild, args: ['tablist',] }],
        tabSelect: [{ type: Output }],
        hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-tabstrip',] }, { type: HostBinding, args: ['class.k-floatwrap',] }, { type: HostBinding, args: ['class.k-header',] }],
        tabsAtTop: [{ type: HostBinding, args: ['class.k-tabstrip-top',] }],
        tabsAtRight: [{ type: HostBinding, args: ['class.k-tabstrip-right',] }],
        tabsAtBottom: [{ type: HostBinding, args: ['class.k-tabstrip-bottom',] }],
        tabsAtLeft: [{ type: HostBinding, args: ['class.k-tabstrip-left',] }],
        dir: [{ type: HostBinding, args: ['attr.dir',] }],
        activeDescendantId: [{ type: HostBinding, args: ['attr.aria-activedescendant',] }],
        tabs: [{ type: ContentChildren, args: [TabStripTabComponent,] }]
    };
    return TabStripComponent;
}());

/**
 * Represents a template that defines the content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerTemplate` directive inside the `<kendo-drawer>` tag.
 * Using this template directive will override all other templates,
 * for example, `kendoDrawerHeaderTemplate` and `kendoDrawerItemTemplate`.
 */
var DrawerTemplateDirective = /** @class */ (function () {
    function DrawerTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    DrawerTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoDrawerTemplate]'
                },] },
    ];
    /** @nocollapse */
    DrawerTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef, decorators: [{ type: Optional }] }
    ]; };
    return DrawerTemplateDirective;
}());

/**
 * Represents a template that defines the item content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerItemTemplate` directive inside the `<kendo-drawer>` tag.
 */
var DrawerItemTemplateDirective = /** @class */ (function () {
    function DrawerItemTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    DrawerItemTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoDrawerItemTemplate]'
                },] },
    ];
    /** @nocollapse */
    DrawerItemTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef, decorators: [{ type: Optional }] }
    ]; };
    return DrawerItemTemplateDirective;
}());

/**
 * Represents a template that defines the header content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerHeaderTemplate` directive inside the `<kendo-drawer>` tag.
 */
var DrawerHeaderTemplateDirective = /** @class */ (function () {
    function DrawerHeaderTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    DrawerHeaderTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoDrawerHeaderTemplate]'
                },] },
    ];
    /** @nocollapse */
    DrawerHeaderTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef, decorators: [{ type: Optional }] }
    ]; };
    return DrawerHeaderTemplateDirective;
}());

/**
 * Represents a template that defines the footer content of the Drawer.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoDrawerFooterTemplate` directive inside the `<kendo-drawer>` tag.
 */
var DrawerFooterTemplateDirective = /** @class */ (function () {
    function DrawerFooterTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    DrawerFooterTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoDrawerFooterTemplate]'
                },] },
    ];
    /** @nocollapse */
    DrawerFooterTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef, decorators: [{ type: Optional }] }
    ]; };
    return DrawerFooterTemplateDirective;
}());

/**
 * @hidden
 */
function miniExpandPush(duration, width, miniWidth) {
    return [
        style({ overflow: 'hidden', flexBasis: miniWidth + "px" }),
        animate(duration + "ms ease-in", style({ flexBasis: width + "px" }))
    ];
}
/**
 * @hidden
 */
function miniCollapsePush(duration, width, miniWidth) {
    return [
        style({ overflow: 'hidden', flexBasis: width + "px" }),
        animate(duration + "ms ease-in", style({ flexBasis: miniWidth + "px" }))
    ];
}
/**
 * @hidden
 *
 */
function miniExpandOverlay(duration, width, miniWidth) {
    return [
        style({ width: miniWidth + "px" }),
        animate(duration + "ms ease-in", style({ overflow: 'hidden', width: width + "px" }))
    ];
}
/**
 * @hidden
 */
function expandPush(duration, width) {
    return [
        style({ overflow: 'hidden', flexBasis: '0px' }),
        animate(duration + "ms ease-in", style({ flexBasis: width + "px" }))
    ];
}
/**
 * @hidden
 */
function collapsePush(duration, width) {
    return [
        style({ flexBasis: width + "px" }),
        animate(duration + "ms ease-in", style({ overflow: 'hidden', flexBasis: "0px" }))
    ];
}
/**
 * @hidden
 */
function expandRTLOverlay(duration) {
    return [
        style({ transform: "translateX(100%)" }),
        animate(duration + "ms ease-in", style({ overflow: 'hidden', transform: "translateX(0)" }))
    ];
}
/**
 * @hidden
 */
function expandOverlay(duration, position) {
    var translateDir = position !== 'end' ? "-100%" : "100%";
    return [
        style({ transform: "translateX(" + translateDir + ")" }),
        animate(duration + "ms ease-in", style({ overflow: 'hidden', transform: "translateX(0)" }))
    ];
}
/**
 * @hidden
 */
function miniCollapseOverlay(duration, width, miniWidth) {
    return [
        style({ width: width + "px" }),
        animate(duration + "ms ease-in", style({ overflow: 'hidden', width: miniWidth + "px" }))
    ];
}
/**
 * @hidden
 */
function collapseOverlay(duration, position) {
    var translateDir = position !== 'end' ? '-100%' : '100%';
    return [
        style({ transform: "translateX(0)" }),
        animate(duration + "ms ease-in", style({ overflow: 'hidden', transform: "translateX(" + translateDir + ")" }))
    ];
}
/**
 * @hidden
 */
function collapseRTLOverlay(duration) {
    return [
        style({ transform: "translateX(0)" }),
        animate(duration + "ms ease-in", style({ overflow: 'hidden', transform: "translateX(100%)" }))
    ];
}
/**
 * @hidden
 */
function expandAnimation(settings) {
    var duration = settings.animation.duration;
    var width = settings.width;
    var miniWidth = settings.miniWidth;
    var mode = settings.mode;
    var mini = settings.mini;
    var rtl = settings.rtl;
    var position = settings.position;
    if (mini && mode === 'push') {
        return miniExpandPush(duration, width, miniWidth);
    }
    if (!mini && mode === 'push') {
        return expandPush(duration, width);
    }
    if (!mini && mode === 'overlay') {
        return rtl ? expandRTLOverlay(duration) : expandOverlay(duration, position);
    }
    if (mini && mode === 'overlay') {
        return miniExpandOverlay(duration, width, miniWidth);
    }
}
/**
 * @hidden
 */
function collapseAnimation(settings) {
    var duration = settings.animation.duration;
    var width = settings.width;
    var miniWidth = settings.miniWidth;
    var mode = settings.mode;
    var mini = settings.mini;
    var rtl = settings.rtl;
    var position = settings.position;
    if (mini && mode === 'push') {
        return miniCollapsePush(duration, width, miniWidth);
    }
    if (!mini && mode === 'push') {
        return collapsePush(duration, width);
    }
    if (!mini && mode === 'overlay') {
        return rtl ? collapseRTLOverlay(duration) : collapseOverlay(duration, position);
    }
    if (mini && mode === 'overlay') {
        return miniCollapseOverlay(duration, width, miniWidth);
    }
}

/**
 * Arguments for the `select` event of the Drawer.
 */
var DrawerSelectEvent = /** @class */ (function (_super) {
    __extends(DrawerSelectEvent, _super);
    function DrawerSelectEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DrawerSelectEvent;
}(PreventableEvent));

/**
 * @hidden
 */
var DrawerService = /** @class */ (function () {
    function DrawerService() {
        this.selectedIndices = [];
    }
    DrawerService.prototype.emit = function (event, args) {
        var drawer = this.owner;
        var eventArgs = new DrawerSelectEvent(__assign({}, args, { sender: drawer }));
        if (hasObservers(drawer[event])) {
            drawer[event].emit(eventArgs);
        }
        return eventArgs.isDefaultPrevented();
    };
    DrawerService.prototype.onSelect = function (selectedIdx) {
        this.selectedIndices = [selectedIdx];
        var drawer = this.owner;
        if (drawer.autoCollapse && !drawer.minimized) {
            drawer.toggle(false);
        }
    };
    DrawerService.decorators = [
        { type: Injectable },
    ];
    return DrawerService;
}());

var DEFAULT_ANIMATION = { type: 'slide', duration: 200 };
/**
 * Represents the [Kendo UI Drawer component for Angular]({% slug overview_drawer %}).
 *
 * @example
 * ```ts-preview
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-drawer [items]="items">
 *        </kendo-drawer>
 *    `
 * })
 * class AppComponent {
 *    public items: any[] = [{ text: 'Inbox', icon: 'k-i-inbox' }];
 * }
 * ```
 */
var DrawerComponent = /** @class */ (function () {
    function DrawerComponent(element, builder, localizationService, drawerService) {
        var _this = this;
        this.element = element;
        this.builder = builder;
        this.localizationService = localizationService;
        this.drawerService = drawerService;
        this.hostClasses = true;
        /**
         * Specifies the mode in which the Drawer will be displayed.
         *
         * The possible values are:
         * * (Default) `overlay`
         * * `push`
         */
        this.mode = 'overlay';
        /**
         * Specifies the position of the Drawer
         * ([see example]({% slug positioning_drawer %})).
         *
         * The possible values are:
         * * (Default) `start`
         * * `end`
         */
        this.position = 'start';
        /**
         * Enables the mini (compact) view of the Drawer which is displayed when the component is collapsed
         * ([see example]({% slug expandmodespositions_drawer %}#toc-mini-view)).
         */
        this.mini = false;
        /**
         * Specifies the state of the Drawer.
         */
        this.expanded = false;
        /**
         * Defines the width of the Drawer when it is expanded.
         * Defaults to `240`.
         */
        this.width = 240;
        /**
         * Defines the width of the Drawer when the mini view is enabled
         * and the component is collapsed. Defaults to `60`.
         */
        this.miniWidth = 50;
        /**
         * Specifies if the Drawer will be automatically collapsed when an item
         * or the overlay is clicked. Defaults to `true`.
         */
        this.autoCollapse = true;
        /**
         * The collection of items that will be rendered in the Drawer.
         */
        this.items = [];
        /**
         * Specifies the animation settings of the Drawer.
         * ([see example]({% slug interaction_drawer %}#toc-toggling-between-states)).
         *
         * The possible values are:
         * * Boolean
         *    * (Default) `true`
         *    * `false`
         * * `DrawerAnimation`
         *    * (Default) `type?: 'slide'`
         *    * `duration`&mdash;Accepts a number in milliseconds. Defaults to `300ms`.
         */
        this.animation = DEFAULT_ANIMATION;
        /**
         * Fires when the Drawer is expanded and its animation is complete.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the Drawer is collapsed and its animation is complete.
         */
        this.collapse = new EventEmitter();
        /**
         * Fires when a Drawer item is selected. This event is preventable.
         */
        this.select = new EventEmitter();
        /**
         * Fires when the `expanded` property of the component was updated.
         * Used to provide a two-way binding for the `expanded` property.
         */
        this.expandedChange = new EventEmitter();
        this.animationEnd = new EventEmitter();
        this.rtl = false;
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.rtl = rtl;
            _this.direction = _this.rtl ? 'rtl' : 'ltr';
        });
        this.drawerService.owner = this;
    }
    Object.defineProperty(DrawerComponent.prototype, "startPositionClass", {
        get: function () {
            return this.position === 'start';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerComponent.prototype, "endPositionClass", {
        get: function () {
            return this.position === 'end';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerComponent.prototype, "overlayTransofrmStyles", {
        get: function () {
            if (this.mode === 'push') {
                return;
            }
            if (this.expanded || this.minimized) {
                return "translateX(0px)";
            }
            return "translateX(-100%)";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerComponent.prototype, "flexStyles", {
        get: function () {
            if (this.mode === 'overlay') {
                return;
            }
            if (!this.expanded && !this.minimized) {
                return 0;
            }
            return this.drawerWidth;
        },
        enumerable: true,
        configurable: true
    });
    DrawerComponent.prototype.ngOnDestroy = function () {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    };
    Object.defineProperty(DrawerComponent.prototype, "minimized", {
        /**
         * @hidden
         */
        get: function () {
            return this.mini && !this.expanded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerComponent.prototype, "drawerWidth", {
        /**
         * @hidden
         */
        get: function () {
            return this.minimized ? this.miniWidth : this.width;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Toggles the visibility of the Drawer.
     *
     * @param expanded? - Boolean. Specifies if the Drawer will be expanded or collapsed.
     */
    DrawerComponent.prototype.toggle = function (expanded) {
        var _this = this;
        var previous = this.expanded;
        var current = isPresent(expanded) ? expanded : !previous;
        if (current === previous) {
            return;
        }
        if (current === true) {
            this.setExpanded(true);
        }
        else if (current === false && !this.animation) {
            this.setExpanded(false);
        }
        if (this.animation) {
            this.animationEnd.pipe(take(1))
                .subscribe(function () { _this.onAnimationEnd(current); });
            this.animate(current);
        }
        else {
            this[current ? 'expand' : 'collapse'].emit();
        }
    };
    DrawerComponent.prototype.onAnimationEnd = function (currentExpanded) {
        if (currentExpanded) {
            this.expand.emit();
        }
        else {
            this.setExpanded(false);
            this.collapse.emit();
        }
    };
    DrawerComponent.prototype.setExpanded = function (value) {
        this.expanded = value;
        this.expandedChange.emit(value);
    };
    DrawerComponent.prototype.animate = function (expanded) {
        var settings = {
            mode: this.mode,
            mini: this.mini,
            miniWidth: this.miniWidth,
            width: this.width,
            rtl: this.rtl,
            position: this.position,
            animation: (typeof this.animation !== 'boolean') ? this.animation : DEFAULT_ANIMATION
        };
        var animation = expanded ? expandAnimation(settings) : collapseAnimation(settings);
        var player = this.createPlayer(animation, this.element.nativeElement);
        player.play();
    };
    DrawerComponent.prototype.createPlayer = function (animation, animatedElement) {
        var _this = this;
        var factory = this.builder.build(animation);
        var player = factory.create(animatedElement);
        player.onDone(function () {
            if (player) {
                _this.animationEnd.emit();
                player.destroy();
                player = null;
            }
        });
        return player;
    };
    DrawerComponent.decorators = [
        { type: Component, args: [{
                    exportAs: 'kendoDrawer',
                    providers: [
                        LocalizationService,
                        DrawerService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.drawer'
                        }
                    ],
                    selector: 'kendo-drawer',
                    template: "\n        <div class=\"k-drawer-wrapper\" *ngIf=\"expanded || mini\" [style.width.px]=\"drawerWidth\">\n            <ng-container *ngIf=\"!drawerTemplate\">\n                <ng-template *ngIf=\"headerTemplate\"\n                    [ngTemplateOutlet]=\"headerTemplate?.templateRef\">\n                </ng-template>\n\n                <ul kendoDrawerList\n                    [items]=\"items\" [mini]=\"mini\" [expanded]=\"expanded\"\n                    [itemTemplate]=\"itemTemplate?.templateRef\"\n                    class=\"k-drawer-items\">\n                </ul>\n\n                <ng-template *ngIf=\"footerTemplate\"\n                    [ngTemplateOutlet]=\"footerTemplate?.templateRef\">\n                </ng-template>\n            </ng-container>\n\n            <ng-template *ngIf=\"drawerTemplate\"\n                [ngTemplateOutlet]=\"drawerTemplate?.templateRef\">\n            </ng-template>\n        </div>\n    "
                },] },
    ];
    /** @nocollapse */
    DrawerComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: AnimationBuilder },
        { type: LocalizationService },
        { type: DrawerService }
    ]; };
    DrawerComponent.propDecorators = {
        hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-drawer',] }],
        startPositionClass: [{ type: HostBinding, args: ['class.k-drawer-start',] }],
        endPositionClass: [{ type: HostBinding, args: ['class.k-drawer-end',] }],
        overlayTransofrmStyles: [{ type: HostBinding, args: ['style.transform',] }],
        flexStyles: [{ type: HostBinding, args: ['style.flexBasis.px',] }],
        mode: [{ type: Input }],
        position: [{ type: Input }],
        mini: [{ type: Input }],
        expanded: [{ type: Input }],
        width: [{ type: Input }],
        miniWidth: [{ type: Input }],
        autoCollapse: [{ type: Input }],
        items: [{ type: Input }],
        direction: [{ type: HostBinding, args: ['attr.dir',] }],
        animation: [{ type: Input }],
        expand: [{ type: Output }],
        collapse: [{ type: Output }],
        select: [{ type: Output }],
        expandedChange: [{ type: Output }],
        drawerTemplate: [{ type: ContentChild, args: [DrawerTemplateDirective,] }],
        footerTemplate: [{ type: ContentChild, args: [DrawerFooterTemplateDirective,] }],
        headerTemplate: [{ type: ContentChild, args: [DrawerHeaderTemplateDirective,] }],
        itemTemplate: [{ type: ContentChild, args: [DrawerItemTemplateDirective,] }]
    };
    return DrawerComponent;
}());

var exportedModules = [
    PanelBarComponent,
    PanelBarItemComponent,
    PanelBarContentDirective,
    PanelBarItemTemplateDirective,
    PanelBarItemTitleDirective
];
var declarations = exportedModules.slice();
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the PanelBar component.
 *
 * The module registers:
 * - `PanelBarComponent`&mdash;The `PanelBar` component class.
 * - `PanelBarItemComponent`&mdash;The `PanelBarItem` component class.
 * - `PanelBarContentComponent`&mdash;The `PanelBarContent` component class.
 * - `PanelBarItemTemplateDirective&mdash;The `PanelBarItemTemplate` directive.
 * - `PanelBarItemTitleDirective&mdash;The `PanelBarItemTitle` directive.
 */
var PanelBarModule = /** @class */ (function () {
    function PanelBarModule() {
    }
    PanelBarModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [declarations],
                    exports: [exportedModules],
                    imports: [CommonModule]
                },] },
    ];
    return PanelBarModule;
}());

var stopPropagation = function (_a) {
    var event = _a.originalEvent;
    event.stopPropagation();
    event.preventDefault();
};
var preventOnDblClick = function (release) { return function (mouseDown) {
    return of(mouseDown).pipe(delay(150), takeUntil(release));
}; };
var classFromObject = function (classes) { return Object.keys(classes).filter(function (c) { return classes[c]; }).join(' '); };
var createMoveStream = function (draggable) { return function (mouseDown) {
    return draggable.kendoDrag
        .pipe(takeUntil(draggable.kendoRelease), map(function (_a) {
        var pageX = _a.pageX, pageY = _a.pageY;
        return ({
            originalX: mouseDown.pageX,
            originalY: mouseDown.pageY,
            pageX: pageX,
            pageY: pageY
        });
    }));
}; };
/**
 * @hidden
 */
var SplitterBarComponent = /** @class */ (function () {
    function SplitterBarComponent(draggable, splitter, localization) {
        this.draggable = draggable;
        this.splitter = splitter;
        this.localization = localization;
        this.orientation = 'horizontal';
        this.index = 0;
        this.ariaRole = 'separator';
        this.focused = false;
        this.subscriptions = new Subscription();
    }
    Object.defineProperty(SplitterBarComponent.prototype, "direction", {
        get: function () {
            return this.localization.rtl ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterBarComponent.prototype, "tabIndex", {
        get: function () {
            return this.splitter.isStatic(this.index) ? -1 : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterBarComponent.prototype, "hostClasses", {
        get: function () {
            var isHorizontal = this.orientation === 'horizontal';
            var isDraggable = this.splitter.isDraggable(this.index);
            var isStatic = this.splitter.isStatic(this.index);
            return classFromObject({
                'k-state-focused': this.focused,
                'k-splitbar': true,
                'k-splitbar-horizontal': isHorizontal,
                'k-splitbar-vertical': !isHorizontal,
                'k-splitbar-draggable-horizontal': isHorizontal && isDraggable,
                'k-splitbar-draggable-vertical': !isHorizontal && isDraggable,
                'k-splitbar-static-horizontal': isHorizontal && isStatic,
                'k-splitbar-static-vertical': !isHorizontal && isStatic
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterBarComponent.prototype, "touchAction", {
        get: function () {
            if (this.splitter.isDraggable(this.index)) {
                return 'none';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterBarComponent.prototype, "order", {
        get: function () {
            return 2 * this.index + 1;
        },
        enumerable: true,
        configurable: true
    });
    SplitterBarComponent.prototype.collapseAny = function () {
        this.tryToggleNearest();
    };
    SplitterBarComponent.prototype.onFocusIn = function () {
        this.focused = true;
    };
    SplitterBarComponent.prototype.onFocusOut = function () {
        this.focused = false;
    };
    SplitterBarComponent.prototype.onKeyDown = function (event) {
        var _this = this;
        var keyCode = event && event.keyCode;
        var isHorizontal = this.orientation === 'horizontal';
        var resize = function (delta) {
            event.preventDefault();
            var state$$1 = _this.splitter.dragState(_this.index);
            _this.splitter.setSize(state$$1, delta);
        };
        if (keyCode === Keys.Enter) {
            event.preventDefault();
            this.tryToggleNearest();
        }
        else if (isHorizontal && keyCode === Keys.ArrowLeft) {
            resize(-10);
        }
        else if (isHorizontal && keyCode === Keys.ArrowRight) {
            resize(10);
        }
        else if (!isHorizontal && keyCode === Keys.ArrowUp) {
            resize(-10);
        }
        else if (!isHorizontal && keyCode === Keys.ArrowDown) {
            resize(10);
        }
    };
    SplitterBarComponent.prototype.ngOnInit = function () {
        var _this = this;
        var state$$1;
        var listener = this.draggable.kendoPress.pipe(tap(stopPropagation), filter(function () { return _this.splitter.isDraggable(_this.index); }), tap(function () { return state$$1 = _this.splitter.dragState(_this.index); }), tap(function () { return _this.splitter.toggleContentOverlay(_this.index, true); }), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.draggable))).subscribe(function (_a) {
            var pageX = _a.pageX, pageY = _a.pageY, originalX = _a.originalX, originalY = _a.originalY;
            var delta;
            if (_this.orientation === 'vertical') {
                delta = pageY - originalY;
            }
            else if (_this.direction === 'rtl') {
                delta = originalX - pageX;
            }
            else {
                delta = pageX - originalX;
            }
            _this.splitter.setSize(state$$1, delta);
        });
        this.subscriptions.add(listener);
        this.subscriptions.add(this.draggable.kendoRelease.subscribe(function () { return _this.splitter.toggleContentOverlay(_this.index, false); }));
    };
    SplitterBarComponent.prototype.ngOnDestroy = function () {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    };
    SplitterBarComponent.prototype.togglePrevious = function () {
        this.splitter.tryToggle(this.index);
    };
    SplitterBarComponent.prototype.toggleNext = function () {
        this.splitter.tryToggle(this.index + 1);
    };
    SplitterBarComponent.prototype.previousArrowClass = function () {
        var pane = this.splitter.pane(this.index);
        var nextPane = this.splitter.pane(this.index + 1);
        var isCollapsible = pane.collapsible;
        var isCollapsed = pane.collapsed;
        var isHorizontal = this.orientation === 'horizontal';
        return classFromObject({
            'k-icon': true,
            'k-hidden': !isCollapsible || nextPane.isHidden,
            'k-collapse-prev': isCollapsible,
            'k-i-arrow-60-left': isCollapsible && isHorizontal && !isCollapsed,
            'k-i-arrow-60-right': isCollapsible && isHorizontal && isCollapsed,
            'k-i-arrow-60-up': isCollapsible && !isHorizontal && !isCollapsed,
            'k-i-arrow-60-down': isCollapsible && !isHorizontal && isCollapsed
        });
    };
    SplitterBarComponent.prototype.nextArrowClass = function () {
        var pane = this.splitter.pane(this.index + 1);
        var prevPane = this.splitter.pane(this.index);
        var isCollapsible = pane.collapsible;
        var isCollapsed = pane.collapsed;
        var isHorizontal = this.orientation === 'horizontal';
        return classFromObject({
            'k-icon': true,
            'k-hidden': !isCollapsible || prevPane.isHidden,
            'k-collapse-next': isCollapsible,
            'k-i-arrow-60-right': isCollapsible && isHorizontal && !isCollapsed,
            'k-i-arrow-60-left': isCollapsible && isHorizontal && isCollapsed,
            'k-i-arrow-60-down': isCollapsible && !isHorizontal && !isCollapsed,
            'k-i-arrow-60-up': isCollapsible && !isHorizontal && isCollapsed
        });
    };
    SplitterBarComponent.prototype.tryToggleNearest = function () {
        var prev = this.index;
        var next = this.index + 1;
        if (!this.splitter.tryToggle(prev)) {
            this.splitter.tryToggle(next);
        }
    };
    SplitterBarComponent.decorators = [
        { type: Component, args: [{
                    selector: 'kendo-splitter-bar',
                    template: "\n      <div [class]=\"previousArrowClass()\" (click)=\"togglePrevious()\"></div>\n      <div class=\"k-resize-handle\"></div>\n      <div [class]=\"nextArrowClass()\" (click)=\"toggleNext()\"></div>\n    "
                },] },
    ];
    /** @nocollapse */
    SplitterBarComponent.ctorParameters = function () { return [
        { type: DraggableDirective, decorators: [{ type: Host }] },
        { type: SplitterService },
        { type: LocalizationService }
    ]; };
    SplitterBarComponent.propDecorators = {
        orientation: [{ type: Input }, { type: HostBinding, args: ['attr.aria-orientation',] }],
        index: [{ type: Input }],
        ariaRole: [{ type: HostBinding, args: ['attr.role',] }],
        focused: [{ type: HostBinding, args: ['class.k-state-focused',] }],
        tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        hostClasses: [{ type: HostBinding, args: ['class',] }],
        touchAction: [{ type: HostBinding, args: ['style.touch-action',] }],
        order: [{ type: HostBinding, args: ['style.-ms-flex-order',] }, { type: HostBinding, args: ['style.order',] }],
        collapseAny: [{ type: HostListener, args: ['dblclick',] }],
        onFocusIn: [{ type: HostListener, args: ['focusin',] }],
        onFocusOut: [{ type: HostListener, args: ['focusout',] }],
        onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
    };
    return SplitterBarComponent;
}());

var exportedModules$1 = [
    SplitterComponent,
    SplitterPaneComponent
];
var declarations$1 = [
    SplitterBarComponent
].concat(exportedModules$1);
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Splitter component.
 *
 * The module registers:
 * - `SplitterComponent`&mdash;The `Splitter` component class.
 * - `SplitterPaneComponent`&mdash;The `SplitterPane` component class.
 */
var SplitterModule = /** @class */ (function () {
    function SplitterModule() {
    }
    SplitterModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [declarations$1],
                    exports: [exportedModules$1],
                    imports: [
                        CommonModule,
                        DraggableModule
                    ]
                },] },
    ];
    return SplitterModule;
}());

var exportedModules$2 = [
    TabStripComponent,
    TabStripTabComponent,
    TabContentDirective,
    TabTitleDirective
];
var declarations$2 = exportedModules$2.slice();
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TabStrip component.
 *
 * The module registers:
 * - `TabStripComponent`&mdash;The `TabStrip` component class.
 * - `TabStripTabComponent`&mdash;The `TabStripTab` component class.
 * - `TabContentDirective`&mdash;The tab content directive used on the `<ng-template>` tag.
 * - `TabTitleDirective`&mdash;The tab title directive used on the `<ng-template>` tag.
 */
var TabStripModule = /** @class */ (function () {
    function TabStripModule() {
    }
    TabStripModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [declarations$2],
                    exports: [exportedModules$2],
                    imports: [CommonModule]
                },] },
    ];
    return TabStripModule;
}());

/**
 * @hidden
 */
var DrawerContainerComponent = /** @class */ (function () {
    function DrawerContainerComponent(localizationService) {
        var _this = this;
        this.localizationService = localizationService;
        this.rtl = false;
        this.dynamicRTLSubscription = this.localizationService.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.rtl = rtl;
            _this.direction = _this.rtl ? 'rtl' : 'ltr';
        });
    }
    Object.defineProperty(DrawerContainerComponent.prototype, "hostClass", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerContainerComponent.prototype, "overlayClass", {
        get: function () {
            return this.drawer.mode === 'overlay';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerContainerComponent.prototype, "miniClass", {
        get: function () {
            return this.drawer.mini;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerContainerComponent.prototype, "pushClass", {
        get: function () {
            return this.drawer.mode === 'push';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerContainerComponent.prototype, "isExpandedClass", {
        get: function () {
            return this.drawer.expanded;
        },
        enumerable: true,
        configurable: true
    });
    DrawerContainerComponent.prototype.ngOnDestroy = function () {
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
    };
    Object.defineProperty(DrawerContainerComponent.prototype, "overlay", {
        get: function () {
            return isPresent(this.drawer) &&
                this.drawer.expanded &&
                this.drawer.mode === 'overlay';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    DrawerContainerComponent.prototype.closeDrawer = function () {
        if (this.overlay && this.drawer.autoCollapse) {
            this.drawer.toggle(false);
        }
    };
    DrawerContainerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'kendo-drawer-container',
                    providers: [
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.drawer.container'
                        }
                    ],
                    template: "\n        <div class=\"k-overlay\" *ngIf=\"overlay\" (click)=\"closeDrawer()\"></div>\n        <ng-content></ng-content>\n    "
                },] },
    ];
    /** @nocollapse */
    DrawerContainerComponent.ctorParameters = function () { return [
        { type: LocalizationService }
    ]; };
    DrawerContainerComponent.propDecorators = {
        hostClass: [{ type: HostBinding, args: ['class.k-drawer-container',] }],
        overlayClass: [{ type: HostBinding, args: ['class.k-drawer-overlay',] }],
        miniClass: [{ type: HostBinding, args: ['class.k-drawer-mini',] }],
        pushClass: [{ type: HostBinding, args: ['class.k-drawer-push',] }],
        isExpandedClass: [{ type: HostBinding, args: ['class.k-drawer-expanded',] }],
        direction: [{ type: HostBinding, args: ['attr.dir',] }],
        drawer: [{ type: ContentChild, args: [DrawerComponent,] }]
    };
    return DrawerContainerComponent;
}());

/**
 * @hidden
 */
var DrawerContentComponent = /** @class */ (function () {
    function DrawerContentComponent() {
        this.hostClasses = true;
    }
    DrawerContentComponent.decorators = [
        { type: Component, args: [{
                    selector: 'kendo-drawer-content',
                    template: "\n        <ng-content></ng-content>\n    ",
                    encapsulation: ViewEncapsulation.None
                },] },
    ];
    /** @nocollapse */
    DrawerContentComponent.ctorParameters = function () { return []; };
    DrawerContentComponent.propDecorators = {
        hostClasses: [{ type: HostBinding, args: ['class.k-drawer-content',] }]
    };
    return DrawerContentComponent;
}());

/**
 * @hidden
 */
var DrawerItemComponent = /** @class */ (function () {
    function DrawerItemComponent(drawer) {
        this.drawer = drawer;
    }
    Object.defineProperty(DrawerItemComponent.prototype, "disabledClass", {
        get: function () {
            return this.item.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerItemComponent.prototype, "selectedClass", {
        get: function () {
            return this.drawer.selectedIndices.indexOf(this.index) >= 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    DrawerItemComponent.prototype.iconClasses = function (icon) {
        return "k-icon " + icon;
    };
    DrawerItemComponent.decorators = [
        { type: Component, args: [{
                    selector: '[kendoDrawerItem]',
                    template: "\n        <ng-template *ngIf=\"itemTemplate; else defaultTemplate\"\n            [ngTemplateOutlet]=\"itemTemplate\"\n            [ngTemplateOutletContext]=\"{ $implicit: item }\">\n        </ng-template>\n\n        <ng-template #defaultTemplate>\n            <ng-container *ngIf=\"expanded\">\n                <span [ngClass]=\"iconClasses(item.icon)\"></span>\n                <span class=\"k-item-text\">{{ item.text }}</span>\n            </ng-container>\n            <ng-container *ngIf=\"mini && !expanded\">\n                <span [ngClass]=\"iconClasses(item.icon)\"></span>\n            </ng-container>\n        </ng-template>\n    "
                },] },
    ];
    /** @nocollapse */
    DrawerItemComponent.ctorParameters = function () { return [
        { type: DrawerService }
    ]; };
    DrawerItemComponent.propDecorators = {
        item: [{ type: Input }],
        index: [{ type: Input }],
        itemTemplate: [{ type: Input }],
        mini: [{ type: Input }],
        expanded: [{ type: Input }],
        disabled: [{ type: Input }],
        cssClass: [{ type: Input }],
        cssStyle: [{ type: Input }],
        disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],
        selectedClass: [{ type: HostBinding, args: ['class.k-state-selected',] }]
    };
    return DrawerItemComponent;
}());

/**
 * @hidden
 */
var DrawerListComponent = /** @class */ (function () {
    function DrawerListComponent(drawerService, renderer, ngZone, changeDetector, element) {
        this.drawerService = drawerService;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.element = element;
    }
    DrawerListComponent.prototype.ngOnInit = function () {
        this.initialSelection();
        this.initDomEvents();
    };
    DrawerListComponent.prototype.ngOnDestroy = function () {
        if (this.clickSubscription) {
            this.clickSubscription();
        }
    };
    DrawerListComponent.prototype.initialSelection = function () {
        var selectedIndices = this.drawerService.selectedIndices;
        if (selectedIndices.length === 0) {
            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i].selected) {
                    selectedIndices.push(i);
                }
            }
        }
    };
    DrawerListComponent.prototype.initDomEvents = function () {
        var _this = this;
        if (!this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(function () {
            var nativeElement = _this.element.nativeElement;
            _this.clickSubscription = _this.renderer.listen(nativeElement, 'click', _this.clickHandler.bind(_this));
        });
    };
    DrawerListComponent.prototype.clickHandler = function (e) {
        // if (isFocusable(e.target) && !hasClass(e.target, 'k-drawer-item')) {
        //     return;
        // }
        var _this = this;
        var itemIdx = this.getDrawerItemIndex(e.target);
        var item = this.items[itemIdx];
        if (!item) {
            return;
        }
        if (item.disabled) {
            e.preventDefault();
            return;
        }
        var args = {
            index: itemIdx,
            item: item,
            originalEvent: e
        };
        this.ngZone.run(function () {
            if (!_this.drawerService.emit('select', args)) {
                _this.drawerService.onSelect(itemIdx);
                _this.changeDetector.detectChanges();
            }
        });
    };
    DrawerListComponent.prototype.getDrawerItemIndex = function (target) {
        var item = closestItem(target, this.element.nativeElement);
        if (item) {
            return itemIndex(item);
        }
    };
    DrawerListComponent.decorators = [
        { type: Component, args: [{
                    selector: '[kendoDrawerList]',
                    template: "\n        <ng-container *ngFor=\"let item of items; let idx = index\">\n            <li *ngIf=\"!item.separator\" kendoDrawerItem\n                class=\"k-drawer-item\"\n                [item]=\"item\"\n                [index]=\"idx\"\n                [mini]=\"mini\"\n                [expanded]=\"expanded\"\n                [itemTemplate]=\"itemTemplate\"\n                [attr." + ITEM_INDEX + "]=\"idx\"\n                [ngClass]=\"item.cssClass\"\n                [ngStyle]=\"item.cssStyle\">\n            </li>\n\n            <li *ngIf=\"item.separator\"\n                class=\"k-drawer-item k-drawer-separator\"\n                [ngClass]=\"item.cssClass\"\n                [ngStyle]=\"item.cssStyle\">\n                &nbsp;\n            </li>\n        </ng-container>\n    "
                },] },
    ];
    /** @nocollapse */
    DrawerListComponent.ctorParameters = function () { return [
        { type: DrawerService },
        { type: Renderer2 },
        { type: NgZone },
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    DrawerListComponent.propDecorators = {
        items: [{ type: Input }],
        itemTemplate: [{ type: Input }],
        mini: [{ type: Input }],
        expanded: [{ type: Input }]
    };
    return DrawerListComponent;
}());

var templateDirectives = [
    DrawerTemplateDirective,
    DrawerHeaderTemplateDirective,
    DrawerFooterTemplateDirective,
    DrawerItemTemplateDirective
];
var exportedModules$3 = [
    DrawerComponent,
    DrawerContainerComponent,
    DrawerContentComponent
].concat(templateDirectives);
var declarations$3 = [
    DrawerItemComponent,
    DrawerListComponent
].concat(exportedModules$3);
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Drawer component.
 */
var DrawerModule = /** @class */ (function () {
    function DrawerModule() {
    }
    DrawerModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [declarations$3],
                    exports: [exportedModules$3],
                    imports: [CommonModule]
                },] },
    ];
    return DrawerModule;
}());

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Layout components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Layout module
 * import { LayoutModule } from '@progress/kendo-angular-layout';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, LayoutModule], // import Layout module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
var LayoutModule = /** @class */ (function () {
    function LayoutModule() {
    }
    LayoutModule.decorators = [
        { type: NgModule, args: [{
                    exports: [
                        PanelBarModule,
                        SplitterModule,
                        TabStripModule,
                        DrawerModule
                    ]
                },] },
    ];
    return LayoutModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { PreventableEvent, DrawerContainerComponent, DrawerContentComponent, DrawerService, DrawerItemComponent, DrawerListComponent, ITEM_INDEX, PanelBarService, SplitterBarComponent, SplitterService, PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective, PanelBarExpandMode, SplitterComponent, SplitterPaneComponent, TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, SelectEvent, DrawerComponent, DrawerSelectEvent, LayoutModule, PanelBarModule, SplitterModule, TabStripModule, DrawerModule, DrawerTemplateDirective, DrawerItemTemplateDirective, DrawerHeaderTemplateDirective, DrawerFooterTemplateDirective };
