/**-----------------------------------------------------------------------------------------
* Copyright © 2019 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { ChangeDetectorRef, Component, ContentChild, Directive, ElementRef, EventEmitter, Host, HostBinding, Inject, Input, NgModule, NgZone, Optional, Output, ViewChild, ViewContainerRef, forwardRef, isDevMode } from '@angular/core';
import { FormControl, FormGroup, FormsModule, NG_VALUE_ACCESSOR, ReactiveFormsModule, Validators } from '@angular/forms';
import { BehaviorSubject, Subject, fromEvent, interval, merge } from 'rxjs';
import { auditTime, concatMap, filter, map, take, takeUntil } from 'rxjs/operators';
import { ToolBarButtonComponent, ToolBarComponent, ToolBarModule, ToolBarToolComponent } from '@progress/kendo-angular-toolbar';
import { DialogContentBase, DialogModule, DialogRef, DialogService } from '@progress/kendo-angular-dialog';
import { KendoInput, isDocumentAvailable } from '@progress/kendo-angular-common';
import { EditorView } from 'prosemirror-view';
import { AllSelection, EditorState, NodeSelection, TextSelection } from 'prosemirror-state';
import { autoJoin, baseKeymap, chainCommands, createParagraphNear, deleteSelection, exitCode, joinBackward, liftEmptyBlock, newlineInCode, selectNodeBackward, setBlockType, splitBlockKeepMarks, toggleMark } from 'prosemirror-commands';
import { keymap } from 'prosemirror-keymap';
import { history, redo, undo } from 'prosemirror-history';
import { __assign, __extends } from 'tslib';
import { DOMParser, DOMSerializer, Fragment, Node, NodeRange, Schema, Slice } from 'prosemirror-model';
import { CellSelection, addColumnAfter, addColumnBefore, addRowAfter, addRowBefore, deleteColumn, deleteRow, deleteTable, mergeCells, splitCell, tableNodes } from 'prosemirror-tables';
import { undoInputRule } from 'prosemirror-inputrules';
import { AddMarkStep, RemoveMarkStep, ReplaceAroundStep, liftTarget } from 'prosemirror-transform';
import { liftListItem, sinkListItem, splitListItem, wrapInList } from 'prosemirror-schema-list';
import { ComponentMessages, L10N_PREFIX, LocalizationService, MessageService, RTL } from '@progress/kendo-angular-l10n';
import { CommonModule } from '@angular/common';
import { DropDownsModule } from '@progress/kendo-angular-dropdowns';
import { ButtonModule } from '@progress/kendo-angular-buttons';
import { ColorPickerModule, NumericTextBoxModule, TextBoxModule } from '@progress/kendo-angular-inputs';
import { PopupService } from '@progress/kendo-angular-popup';

/**
 * @hidden
 */
function outerWidth(element) {
    var width = element.offsetWidth;
    var style = getComputedStyle(element);
    width += (parseFloat(style.marginLeft) || 0 + parseFloat(style.marginRight) || 0);
    return width;
}
/**
 * @hidden
 */
var serializeDOMAttrs = function (el) {
    return Array.from(el.attributes)
        .reduce(function (acc, curr) {
        var _a;
        return Object.assign({}, acc, (_a = {}, _a[curr.name] = curr.value, _a));
    }, {});
};
/**
 * @hidden
 */
var removeEntries = function (obj, predicate) {
    return Object.keys(obj)
        .filter(function (key) { return predicate(key); })
        .reduce(function (acc, curr) {
        var _a;
        return Object.assign(acc, (_a = {}, _a[curr] = obj[curr], _a));
    }, {});
};
/**
 * @hidden
 */
var removeEmptyEntries = function (obj) {
    var predicate = function (key) { return obj[key] !== null && obj[key] !== undefined && obj[key] !== ''; };
    return removeEntries(obj, predicate);
};
/**
 * @hidden
 */
var isEmpty = function (obj) { return Object.keys(obj).length === 0; };
/**
 * @hidden
 */
var isNullOrUndefined = function (value) { return value === undefined || value === null; };
/**
 * @hidden
 */
var isPresent = function (value) { return !isNullOrUndefined(value); };
/**
 * @hidden
 */
var detectIE = function () {
    if (!isDocumentAvailable()) {
        return false;
    }
    var ua = window.navigator.userAgent;
    var msie = ua.indexOf('MSIE ');
    var trident = ua.indexOf('Trident/');
    return msie > 0 || trident > 0;
};
/**
 * @hidden
 */
var safeString = function (value) { return isNullOrUndefined(value) ? '' : value.toString(); };
/**
 * @hidden
 */
var first = function (arr) { return arr[0]; };
/**
 * @hidden
 */
var last = function (arr) { return arr[arr.length - 1]; };
/**
 * @hidden
 */
var unique = function (arr) { return Array.from(new Set(arr)); };
/**
 * @hidden
 */
var split = function (splitter) { return function (value) { return value.split(splitter); }; };
/**
 * @hidden
 */
var trim = function (value) { return value.trim(); };
/**
 * @hidden
 */
var filter$1 = function (predicate) { return function (arr) { return arr.filter(predicate); }; };
/**
 * @hidden
 */
var toArray = function (x) { return x instanceof Array ? x : [x]; };

var SLOT = 0; //https://prosemirror.net/docs/guide/#schema.serialization_and_parsing
var commonAttributes = function () {
    return {
        class: { default: null },
        id: { default: null },
        style: { default: null }
    };
};
var ɵ1 = function (dom) { return ({
    href: dom.getAttribute('href'),
    target: dom.getAttribute('target'),
    title: dom.getAttribute('title')
}); };
var ɵ2 = function (mark) { return [
    'a',
    // Add default value for href. Otherwise the link is not rendered properly(blue with underline)
    Object.assign({}, { href: '' }, removeEmptyEntries(mark.attrs)),
    SLOT
]; };
var ɵ3 = function () { return ['em', SLOT]; };
var ɵ4 = function (value) { return /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null; };
var ɵ5 = function () { return ['strong', SLOT]; };
var ɵ6 = function () { return ['code', SLOT]; };
var ɵ7 = function () { return ['u', SLOT]; };
var ɵ8 = function () { return ['del', SLOT]; };
var ɵ9 = function () { return ['sub', SLOT]; };
var ɵ10 = function () { return ['sup', SLOT]; };
var ɵ11 = function (dom) { return ({
    style: dom.getAttribute('style')
}); };
var ɵ12 = function (mark) { return ['span', Object.assign({}, removeEmptyEntries(mark.attrs)), SLOT]; };
/**
 * @hidden
 */
var marks = {
    // :: MarkSpec A link. Has `href` and `title` attributes. `title`
    // defaults to an empty string. Rendered and parsed as an `<a>`
    // element.
    link: {
        attrs: {
            href: { default: '' },
            target: { default: null },
            title: { default: null }
        },
        inclusive: false,
        parseDOM: [
            {
                getAttrs: ɵ1,
                tag: 'a[href]'
            }
        ],
        toDOM: ɵ2
    },
    // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.
    // Has parse rules that also match `<i>` and `font-style: italic`.
    em: {
        parseDOM: [{ tag: 'i' }, { tag: 'em' }, { style: 'font-style=italic' }],
        toDOM: ɵ3
    },
    // :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules
    // also match `<b>` and `font-weight: bold`.
    strong: {
        parseDOM: [
            { tag: 'strong' },
            // This works around a Google Docs misbehavior where
            // pasted content will be inexplicably wrapped in `<b>`
            // tags with a font-weight normal `{tag: 'b', getAttrs: node => node.style.fontWeight != 'normal' && null}`,
            {
                // According to the docs, the value can be a DOM element (for tag rules) or a string (for style rules).
                getAttrs: ɵ4,
                style: 'font-weight'
            }
        ],
        toDOM: ɵ5
    },
    // :: MarkSpec Code font mark. Represented as a `<code>` element.
    code: {
        parseDOM: [{ tag: 'code' }],
        toDOM: ɵ6
    },
    // :: MarkSpec An underline mark. Rendered as a `<u>` element.
    // Parse rules also match `text-decoration: underline`.
    underline: {
        parseDOM: [{ tag: 'u' }, { style: 'text-decoration=underline' }],
        toDOM: ɵ7
    },
    // :: MarkSpec A strikethrough mark. Rendered as a `<del>` element.
    // Parse rules also match `<s>`, `<strike>`, `text-decoration: line-through`.
    strikethrough: {
        parseDOM: [{ tag: 'del' }, { tag: 's' }, { tag: 'strike' }, { style: 'text-decoration=line-through' }],
        toDOM: ɵ8
    },
    // :: MarkSpec A subscript mark. Rendered as a `<sub>` element.
    // Parse rules also match `vertical-align: sub`.
    subscript: {
        parseDOM: [{ tag: 'sub' }, { style: 'vertical-align=sub' }],
        toDOM: ɵ9
    },
    // :: MarkSpec A superscript mark. Rendered as a `<sup>` element.
    // Parse rules also match `vertical-align: super`.
    superscript: {
        parseDOM: [{ tag: 'sup' }, { style: 'vertical-align=super' }],
        toDOM: ɵ10
    },
    style: {
        attrs: __assign({}, commonAttributes(), { style: {} }),
        parseDOM: [
            {
                // think about a way to remove span tags with empty style attributes or no style attributes at all
                getAttrs: ɵ11,
                tag: 'span[style]'
            }
        ],
        toDOM: ɵ12
    }
};
var kendoTableNodes = function () {
    var tableGroup = 'block';
    var nodes = tableNodes({ tableGroup: tableGroup, cellContent: 'block+', cellAttributes: commonAttributes });
    return Object.assign(nodes, {
        table: {
            attrs: __assign({}, commonAttributes(), { class: { default: 'k-table' }, cellspacing: { default: null }, cellpadding: { default: null } }),
            content: "table_row+",
            tableRole: "table",
            isolating: true,
            group: tableGroup,
            parseDOM: [
                {
                    getAttrs: serializeDOMAttrs,
                    tag: "table"
                }
            ],
            toDOM: function (node) { return ["table", removeEmptyEntries(node.attrs), ["tbody", 0]]; }
        }
    });
};
var ɵ14 = function (node) { return (isEmpty(node.attrs) ? ['p', SLOT] : ['p', removeEmptyEntries(node.attrs), SLOT]); };
var ɵ15 = function (node) { return ['blockquote', removeEmptyEntries(node.attrs), SLOT]; };
var ɵ16 = function () { return ['hr']; };
var ɵ17 = function (dom) { return Object.assign({}, serializeDOMAttrs(dom), { level: 1 }); };
var ɵ18 = function (dom) { return Object.assign({}, serializeDOMAttrs(dom), { level: 2 }); };
var ɵ19 = function (dom) { return Object.assign({}, serializeDOMAttrs(dom), { level: 3 }); };
var ɵ20 = function (dom) { return Object.assign({}, serializeDOMAttrs(dom), { level: 4 }); };
var ɵ21 = function (dom) { return Object.assign({}, serializeDOMAttrs(dom), { level: 5 }); };
var ɵ22 = function (dom) { return Object.assign({}, serializeDOMAttrs(dom), { level: 6 }); };
var ɵ23 = function (node) {
    var attrs = removeEntries(node.attrs, function (key) { return key !== 'level'; });
    return ['h' + node.attrs.level, removeEmptyEntries(attrs), SLOT];
};
var ɵ24 = function () { return ['pre', ['code', SLOT]]; };
var ɵ25 = function (dom) { return ({
    alt: dom.getAttribute('alt'),
    height: dom.getAttribute('height'),
    src: dom.getAttribute('src'),
    width: dom.getAttribute('width')
}); };
var ɵ26 = function (node) { return ['img', removeEmptyEntries(node.attrs)]; };
var ɵ27 = function () { return ['br']; };
var ɵ28 = function (node) { return ['li', removeEmptyEntries(node.attrs), SLOT]; };
var ɵ29 = function (dom) { return ({
    order: dom.hasAttribute('start') ? parseInt(dom.getAttribute('start'), 10) : 1
}); };
var ɵ30 = function (node) { return (node.attrs.order === 1 ? ['ol', SLOT] : ['ol', { start: node.attrs.order }, SLOT]); };
var ɵ31 = function () { return ['ul', SLOT]; };
/**
 * @hidden
 */
var nodes = __assign({ 
    // :: NodeSpec The top level document node.
    doc: {
        content: 'block+'
    }, 
    // :: NodeSpec A plain textblock paragraph. Represented
    // as a `<p>` element in the DOM.
    paragraph: {
        attrs: __assign({}, commonAttributes()),
        content: 'inline*',
        group: 'block',
        parseDOM: [
            {
                getAttrs: serializeDOMAttrs,
                tag: 'p'
            }
        ],
        toDOM: ɵ14
    }, 
    // :: NodeSpec A blockquote (`<blockquote>`) which wraps one or more blocks.
    blockquote: {
        attrs: __assign({}, commonAttributes()),
        content: 'inline*',
        defining: true,
        group: 'block',
        parseDOM: [{ tag: 'blockquote' }],
        toDOM: ɵ15
    }, 
    // :: NodeSpec A horizontal (`<hr>`) rule.
    horizontalRule: {
        group: 'block',
        parseDOM: [{ tag: 'hr' }],
        toDOM: ɵ16
    }, 
    // :: NodeSpec A heading textblock with a `level` attribute that
    // has to hold a number from 1 to 6. Parsed and serialized as an `<h1>` to
    // an `<h6>` element.
    heading: {
        attrs: __assign({ level: { default: 1 } }, commonAttributes()),
        content: 'inline*',
        defining: true,
        group: 'block',
        parseDOM: [
            { tag: 'h1', getAttrs: ɵ17 },
            { tag: 'h2', getAttrs: ɵ18 },
            { tag: 'h3', getAttrs: ɵ19 },
            { tag: 'h4', getAttrs: ɵ20 },
            { tag: 'h5', getAttrs: ɵ21 },
            { tag: 'h6', getAttrs: ɵ22 }
        ],
        toDOM: ɵ23
    }, 
    // :: NodeSpec A code listing. Prevents marks or non-text inline
    // nodes by default. Represented as a `<pre>` element with a
    // `<code>` element inside.
    codeBlock: {
        code: true,
        content: 'text*',
        defining: true,
        group: 'block',
        marks: '',
        parseDOM: [
            {
                preserveWhitespace: 'full',
                tag: 'pre'
            }
        ],
        toDOM: ɵ24
    }, 
    // :: NodeSpec The text node.
    text: {
        group: 'inline'
    }, 
    // :: NodeSpec An inline image (`<img>`) node. Supports `src`,
    // `alt`, and `href` attributes. The last two default to an empty
    // string.
    image: {
        attrs: __assign({}, commonAttributes(), { alt: { default: null }, height: { default: null }, src: {}, width: { default: null } }),
        draggable: true,
        group: 'inline',
        inline: true,
        parseDOM: [
            {
                getAttrs: ɵ25,
                tag: 'img[src]'
            }
        ],
        toDOM: ɵ26
    }, 
    // :: NodeSpec A hard line break. Represented as a `<br>` element in the DOM.
    hardBreak: {
        group: 'inline',
        inline: true,
        parseDOM: [{ tag: 'br' }],
        selectable: false,
        toDOM: ɵ27
    }, 
    // :: NodeSpec A list item. Represented as a `<li>` element.
    listItem: {
        attrs: __assign({}, commonAttributes()),
        content: 'paragraph block*',
        marks: '_',
        parseDOM: [{ tag: 'li' }],
        toDOM: ɵ28
    }, 
    // :: NodeSpec An ordered list. Represented as an `<ol>` element.
    // Has a single `order` attribute which determines the number at which
    // the list starts counting. Defaults to 1.
    orderedList: {
        attrs: {
            order: {
                default: 1
            }
        },
        content: 'listItem+',
        group: 'block',
        parseDOM: [
            {
                getAttrs: ɵ29,
                tag: 'ol'
            }
        ],
        toDOM: ɵ30
    }, 
    // :: NodeSec An unordered list. Represented as a `<ul>` element.
    bulletList: {
        content: 'listItem+',
        group: 'block',
        parseDOM: [{ tag: 'ul' }],
        toDOM: ɵ31
    } }, kendoTableNodes());
/**
 * @hidden
 */
var schema = new Schema({
    marks: marks,
    nodes: nodes
});

/**
 * @hidden
 */
var rootListDepth = function (pos, nodes) {
    // Get the depth of the nearest ancestor list
    var bulletList = nodes.bulletList, orderedList = nodes.orderedList, listItem = nodes.listItem;
    var depth;
    for (var i = pos.depth - 1; i > 0; i--) {
        var node = pos.node(i);
        if (node.type === bulletList || node.type === orderedList) {
            depth = i;
        }
        if (node.type !== bulletList && node.type !== orderedList && node.type !== listItem) {
            break;
        }
    }
    return depth;
};
/**
 * @hidden
 */
var getListLiftTarget = function (schema, resPos) {
    // This will return (depth - 1) for root list parent of a list.
    var target = resPos.depth;
    var _a = schema.nodes, bulletList = _a.bulletList, orderedList = _a.orderedList, listItem = _a.listItem;
    for (var i = resPos.depth; i > 0; i--) {
        var node = resPos.node(i);
        if (node.type === bulletList || node.type === orderedList) {
            target = i;
        }
        if (node.type !== bulletList && node.type !== orderedList && node.type !== listItem) {
            break;
        }
    }
    return target - 1;
};
/**
 * @hidden
 */
function liftSelectionList(state, tr) {
    // The function will list paragraphs in selection out to level 1 below root list.
    var _a = state.selection, from = _a.from, to = _a.to;
    var paragraph = state.schema.nodes.paragraph;
    var listCol = [];
    tr.doc.nodesBetween(from, to, function (node, pos) {
        if (node.type === paragraph) {
            listCol.push({ node: node, pos: pos });
        }
    });
    for (var i = listCol.length - 1; i >= 0; i--) {
        var paragr = listCol[i];
        var start = tr.doc.resolve(tr.mapping.map(paragr.pos));
        if (start.depth > 0) {
            var end = void 0;
            if (paragr.node.textContent && paragr.node.textContent.length > 0) {
                end = tr.doc.resolve(tr.mapping.map(paragr.pos + paragr.node.textContent.length));
            }
            else {
                end = tr.doc.resolve(tr.mapping.map(paragr.pos + 1));
            }
            var range = start.blockRange(end);
            if (range) {
                tr.lift(range, getListLiftTarget(state.schema, start));
            }
        }
    }
    return tr;
}
/**
 * @hidden
 */
var toggleList = function (state, dispatch, view, listType) {
    var selection = state.selection;
    var fromNode = selection.$from.node(selection.$from.depth - 2);
    var endNode = selection.$to.node(selection.$to.depth - 2);
    if (!fromNode || fromNode.type.name !== listType || (!endNode || endNode.type.name !== listType)) {
        return toggleListCommand(listType)(state, dispatch, view);
    }
    else {
        var depth = rootListDepth(selection.$to, state.schema.nodes);
        var tr = liftFollowingList(state, selection.$to.pos, selection.$to.end(depth), depth, state.tr);
        tr = liftSelectionList(state, tr);
        dispatch(tr);
        return true;
    }
};
/**
 * @hidden
 */
function toggleListCommand(listType) {
    return function (state, dispatch, view) {
        if (!view) {
            return false;
        }
        state = view.state;
        var _a = state.selection, $from = _a.$from, $to = _a.$to;
        var parent = $from.node(-2);
        var grandgrandParent = $from.node(-3);
        var isRangeOfSingleType = isRangeOfType(state.doc, $from, $to, state.schema.nodes[listType]);
        if (((parent && parent.type === state.schema.nodes[listType]) ||
            (grandgrandParent && grandgrandParent.type === state.schema.nodes[listType])) &&
            isRangeOfSingleType) {
            // Untoggles list
            return liftListItems()(state, dispatch);
        }
        else {
            // Wraps selection in list and converts list type e.g. bullet_list -> ordered_list if needed
            if (!isRangeOfSingleType) {
                liftListItems()(state, dispatch);
                state = view.state;
            }
            return wrapInList$1(state.schema.nodes[listType])(state, dispatch);
        }
    };
}
/**
 * @hidden
 */
function liftListItem$1(state, selection, tr) {
    var $from = selection.$from, $to = selection.$to;
    var nodeType = state.schema.nodes.listItem;
    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type === nodeType; });
    if (!range || range.depth < 2 || $from.node(range.depth - 1).type !== nodeType) {
        return tr;
    }
    var end = range.end;
    var endOfList = $to.end(range.depth);
    if (end < endOfList) {
        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(nodeType.create(undefined, range.parent.copy())), 1, 0), 1, true));
        range = new NodeRange(tr.doc.resolve($from.pos), tr.doc.resolve(endOfList), range.depth);
    }
    return tr.lift(range, liftTarget(range)).scrollIntoView();
}
/**
 * @hidden
 */
function liftFollowingList(state, from, to, rootListDepthNum, tr) {
    // Function will lift list item following selection to level-1.
    var listItem = state.schema.nodes.listItem;
    var lifted = false;
    tr.doc.nodesBetween(from, to, function (node, pos) {
        if (!lifted && node.type === listItem && pos > from) {
            lifted = true;
            var listDepth = rootListDepthNum + 3;
            while (listDepth > rootListDepthNum + 2) {
                var start = tr.doc.resolve(tr.mapping.map(pos));
                listDepth = start.depth;
                var end = tr.doc.resolve(tr.mapping.map(pos + node.textContent.length));
                var sel = new TextSelection(start, end);
                tr = liftListItem$1(state, sel, tr);
            }
        }
    });
    return tr;
}
/**
 * @hidden
 */
function isRangeOfType(doc, $from, $to, nodeType) {
    // Step through block-nodes between $from and $to and returns false if a node is
    // found that isn't of the specified type
    return getAncestorNodesBetween(doc, $from, $to).filter(function (node) { return node.type !== nodeType; }).length === 0;
}
/**
 * @hidden
 */
function getAncestorNodesBetween(doc, $from, $to) {
    // Returns all top-level ancestor-nodes between $from and $to
    var nodes = Array();
    var maxDepth = findAncestorPosition(doc, $from).depth;
    var current = doc.resolve($from.start(maxDepth));
    while (current.pos <= $to.start($to.depth)) {
        var depth = Math.min(current.depth, maxDepth);
        var node = current.node(depth);
        if (node) {
            nodes.push(node);
        }
        if (depth === 0) {
            break;
        }
        var next = doc.resolve(current.after(depth));
        if (next.start(depth) >= doc.nodeSize - 2) {
            break;
        }
        if (next.depth !== current.depth) {
            next = doc.resolve(next.pos + 2);
        }
        if (next.depth) {
            current = doc.resolve(next.start(next.depth));
        }
        else {
            current = doc.resolve(next.end(next.depth));
        }
    }
    return nodes;
}
/**
 * @hidden
 */
function findAncestorPosition(doc, pos) {
    // Traverse the document until an "ancestor" is found. Any nestable block can be an ancestor.
    var nestableBlocks = ['blockquote', 'bulletList', 'orderedList'];
    if (pos.depth === 1) {
        return pos;
    }
    var node = pos.node(pos.depth);
    var newPos = pos;
    while (pos.depth >= 1) {
        pos = doc.resolve(pos.before(pos.depth));
        node = pos.node(pos.depth);
        if (node && nestableBlocks.indexOf(node.type.name) !== -1) {
            newPos = pos;
        }
    }
    return newPos;
}
/**
 * @hidden
 */
function liftListItems() {
    return function (state, dispatch) {
        var tr = state.tr;
        var _a = state.selection, $from = _a.$from, $to = _a.$to;
        tr.doc.nodesBetween($from.pos, $to.pos, function (node, pos) {
            // Following condition will ensure that block types paragraph, heading, codeBlock, blockquote, panel are lifted.
            // isTextblock is true for paragraph, heading, codeBlock.
            if (node.isTextblock || node.type.name === 'blockquote' || node.type.name === 'panel') {
                var sel = new NodeSelection(tr.doc.resolve(tr.mapping.map(pos)));
                var range = sel.$from.blockRange(sel.$to);
                if (!range || sel.$from.parent.type !== state.schema.nodes.listItem) {
                    return false;
                }
                var target = range && liftTarget(range);
                if (target === undefined || target === null) {
                    return false;
                }
                tr.lift(range, target);
            }
        });
        if (dispatch) {
            dispatch(tr);
        }
        return true;
    };
}
/**
 * @hidden
 */
function wrapInList$1(nodeType) {
    return autoJoin(wrapInList(nodeType), function (before, after) { return before.type === after.type && before.type === nodeType; });
}
/**
 * @hidden
 */
function toggleUnorderedList(state, dispatch, view) {
    return toggleList(state, dispatch, view, 'bulletList');
}
/**
 * @hidden
 */
function toggleOrderedList(state, dispatch, view) {
    return toggleList(state, dispatch, view, 'orderedList');
}
/**
 * @hidden
 */
var splitListItemKeepMarks = function (itemType) { return function (state, dispatch) {
    // see https://github.com/ProseMirror/prosemirror-commands/blob/master/src/commands.js#L321-L327
    return splitListItem(itemType)(state, function (tr) {
        var marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());
        if (marks) {
            tr.ensureMarks(marks);
        }
        dispatch(tr);
    });
}; };

var mac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
// https://github.com/ProseMirror/prosemirror-example-setup/blob/master/src/keymap.js
/**
 * @hidden
 */
var buildKeymap = function (schema) {
    var keys = {};
    keys['Mod-z'] = undo;
    keys['Shift-Mod-z'] = redo;
    // tslint:disable-next-line:no-string-literal
    keys['Backspace'] = chainCommands(undoInputRule, deleteSelection, joinBackward, selectNodeBackward);
    // tslint:disable-next-line:no-string-literal
    keys['Enter'] = chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlockKeepMarks);
    if (!mac) {
        keys['Mod-y'] = redo;
    }
    if (schema.marks.strong) {
        keys['Mod-b'] = toggleMark(schema.marks.strong);
    }
    if (schema.marks.em) {
        keys['Mod-i'] = toggleMark(schema.marks.em);
    }
    if (schema.marks.underline) {
        keys['Mod-u'] = toggleMark(schema.marks.underline);
    }
    if (schema.nodes.hardBreak) {
        var br_1 = schema.nodes.hardBreak;
        var cmd = chainCommands(exitCode, function (state, dispatch) {
            dispatch(state.tr.replaceSelectionWith(br_1.create()).scrollIntoView());
            return true;
        });
        keys['Mod-Enter'] = cmd;
        keys['Shift-Enter'] = cmd;
        if (mac) {
            keys['Ctrl-Enter'] = cmd;
        }
    }
    return keys;
};
/**
 * @hidden
 */
var buildListKeymap = function (schema) {
    var keys = {};
    if (schema.nodes.listItem) {
        // tslint:disable-next-line:no-string-literal
        keys['Enter'] = splitListItemKeepMarks(schema.nodes.listItem);
    }
    return keys;
};

var style = function (name, value) {
    return { name: name, value: value };
};
/**
 * @hidden
 */
var alignLeftRules = [
    { node: 'paragraph', style: [style('text-align', 'left')] },
    { node: 'heading', style: [style('text-align', 'left')] },
    { node: 'listItem', style: [style('text-align', 'left'), style('list-style-position', 'inside')] }
];
/**
 * @hidden
 */
var alignRightRules = [
    { node: 'paragraph', style: [style('text-align', 'right')] },
    { node: 'heading', style: [style('text-align', 'right')] },
    { node: 'listItem', style: [style('text-align', 'right'), style('list-style-position', 'inside')] }
];
/**
 * @hidden
 */
var alignCenterRules = [
    { node: 'paragraph', style: [style('text-align', 'center')] },
    { node: 'heading', style: [style('text-align', 'center')] },
    { node: 'listItem', style: [style('text-align', 'center'), style('list-style-position', 'inside')] }
];
/**
 * @hidden
 */
var alignRemoveRules = [
    { node: 'paragraph', style: [style('text-align', '')] },
    { node: 'heading', style: [style('text-align', '')] },
    { node: 'listItem', style: [style('text-align', ''), style('list-style-position', '')] }
];

var changeStyles = function (elementStyle, newStyle) {
    var styleToChange = newStyle.style;
    var regExp = newStyle.value;
    var newValue = newStyle.newValue;
    var styleMatches = [];
    if (elementStyle) {
        var splits = elementStyle.split(/\s*;\s*/).filter(function (s) { return s; });
        var filtered = splits.filter(function (s) {
            if (!s
                .toLowerCase()
                .trim()
                .startsWith(styleToChange)) {
                return true;
            }
            var value = s.split(':')[1].trim();
            if (regExp.test(value)) {
                styleMatches.push(value);
                return false;
            }
            return true;
        });
        if (newValue) {
            filtered.push(styleToChange + ": " + newValue);
        }
        return {
            changed: !!newValue || filtered.length !== splits.length,
            style: filtered.join('; ') + (filtered.length ? ';' : ''),
            styleMatches: styleMatches
        };
    }
    return { changed: false, styleMatches: styleMatches, style: null };
};
var changeStyleFromMark = function (marks, toChange) {
    var styleMark = marks.find(function (m) { return m.type.name === 'style'; });
    var elementStyle = styleMark && styleMark.attrs.style;
    return changeStyles(elementStyle, toChange);
};
var changeStyleMark = function (tr, from, to, attrs, markType) {
    var mark = markType.create({ style: attrs.style });
    var removed = [], added = [], removing = null, adding = null;
    tr.doc.nodesBetween(from, to, function (node, pos, parent) {
        if (!node.isInline) {
            return;
        }
        var marks = node.marks;
        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
            var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
            var newStyle = changeStyleFromMark(marks, attrs);
            if (newStyle.changed || attrs.newValue) {
                var style = newStyle.changed ? { style: newStyle.style } : { style: [attrs.style] + ": " + attrs.newValue + ";" };
                var newStyleMark = markType.create(style);
                var newSet = newStyleMark.addToSet(marks);
                for (var i = 0; i < marks.length; i++) {
                    if (!marks[i].isInSet(newSet)) {
                        if (removing && removing.to === start && removing.mark.eq(marks[i])) {
                            removing.to = end;
                        }
                        else {
                            removing = new RemoveMarkStep(start, end, marks[i]);
                            removed.push(removing);
                        }
                    }
                }
                var previousAdded = adding && adding.to === start;
                var sameAdding = previousAdded && newStyleMark.attrs.style === adding.mark.attrs.style;
                if (previousAdded && sameAdding) {
                    adding.to = end;
                }
                else if (newStyleMark.attrs.style) {
                    adding = new AddMarkStep(start, end, newStyleMark);
                    added.push(adding);
                }
            }
        }
    });
    removed.forEach(function (s) { return tr.step(s); });
    added.forEach(function (s) { return tr.step(s); });
    return removed.length + added.length > 0;
};
var markApplies = function (doc, ranges, type) {
    var loop = function (i) {
        var ref = ranges[i];
        var $from = ref.$from;
        var $to = ref.$to;
        var can = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;
        doc.nodesBetween($from.pos, $to.pos, function (node) {
            if (can) {
                return false;
            }
            can = node.inlineContent && node.type.allowsMarkType(type);
        });
        if (can) {
            return { v: true };
        }
    };
    for (var i = 0; i < ranges.length; i++) {
        var returned = loop(i);
        if (returned) {
            return returned.v;
        }
    }
    return false;
};
/**
 * @hidden
 */
var changeStyle = function (markType, attrs) {
    return function (state, dispatch, tr) {
        var _a = state.selection, empty = _a.empty, $cursor = _a.$cursor, ranges = _a.ranges;
        if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) {
            return false;
        }
        var result = false;
        if (dispatch) {
            tr = tr || state.tr;
            if ($cursor) {
                var currentMarks = state.storedMarks || $cursor.marks();
                if (markType.isInSet(currentMarks)) {
                    var newStyle = changeStyleFromMark(currentMarks, attrs);
                    dispatch(tr.removeStoredMark(markType));
                    dispatch(tr.addStoredMark(markType.create({ style: newStyle.style })));
                    result = true;
                }
            }
            else {
                for (var i = 0; i < ranges.length; i++) {
                    var _b = ranges[i], $from = _b.$from, $to = _b.$to;
                    result = changeStyleMark(tr, $from.pos, $to.pos, attrs, markType);
                }
                if (result) {
                    tr.scrollIntoView();
                    dispatch(tr);
                }
            }
        }
        return result;
    };
};
var canChangeType = function (stateDoc, pos, type) {
    var $pos = stateDoc.resolve(pos), index = $pos.index();
    return $pos.parent.canReplaceWith(index, index + 1, type);
};
/**
 * @hidden
 */
var changeBlockNode = function (state, dispatch, tr, node, nodeType, attrs) {
    var _a = state.selection, from = _a.from, to = _a.to;
    var applicable = false;
    state.doc.nodesBetween(from, to, function (currNode, pos) {
        if (applicable) {
            return false;
        }
        if (!currNode.isTextblock || currNode.hasMarkup(nodeType, attrs)) {
            return;
        }
        if (currNode.type === nodeType) {
            applicable = true;
        }
        else {
            var $pos = state.doc.resolve(pos), index = $pos.index();
            applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
        }
    });
    if (!applicable) {
        return false;
    }
    if (dispatch) {
        if (!nodeType.isTextblock) {
            throw new RangeError('Type given to setBlockType should be a textblock');
        }
        var mapFrom_1 = tr.steps.length;
        tr.doc.nodesBetween(from, to, function (currNode, pos) {
            if (currNode.eq(node) &&
                currNode.isTextblock &&
                !currNode.hasMarkup(nodeType, attrs) &&
                canChangeType(tr.doc, tr.mapping.slice(mapFrom_1).map(pos), nodeType)) {
                // Ensure all markup that isn't allowed in the new node type is cleared
                tr.clearIncompatible(tr.mapping.slice(mapFrom_1).map(pos, 1), nodeType);
                var mapping = tr.mapping.slice(mapFrom_1);
                var startM = mapping.map(pos, 1), endM = mapping.map(pos + currNode.nodeSize, 1);
                var slice = new Slice(Fragment.from(nodeType.create(attrs, null, currNode.marks)), 0, 0);
                tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, slice, 1, true));
                return false; // this will skip the node children
            }
        });
    }
    return true;
};
/**
 * @hidden
 */
function getMarkRange($cursor, markType) {
    var parentNode = $cursor.parent;
    var cursorNodeIndex = $cursor.index();
    var mark = parentNode.child(cursorNodeIndex).marks.find(function (m) { return m.type === markType; });
    var childCount = parentNode.childCount;
    var start = $cursor.pos - $cursor.textOffset, end = parentNode.child(cursorNodeIndex).nodeSize, index, nodeSize;
    index = cursorNodeIndex - 1;
    while (index >= 0 && mark.isInSet(parentNode.child(index).marks)) {
        nodeSize = parentNode.child(index).nodeSize;
        end += nodeSize;
        start -= nodeSize;
        index -= 1;
    }
    index = cursorNodeIndex + 1;
    while (index < childCount && mark.isInSet(parentNode.child(index).marks)) {
        end += parentNode.child(index).nodeSize;
        index += 1;
    }
    return { from: start, to: start + end };
}
/**
 * @hidden
 */
var modifyMark = function (markType, attrs) { return function (state, dispatch) {
    var tr = state.tr;
    var _a = state.selection, $cursor = _a.$cursor, from = _a.from, to = _a.to;
    if (!$cursor) {
        tr.doc.nodesBetween(from, to, function (node, pos) {
            if (node.isInline && markType.isInSet(node.marks)) {
                tr.removeMark(pos, pos + node.nodeSize, markType);
                tr.addMark(pos, pos + node.nodeSize, markType.create(attrs));
                dispatch(tr);
            }
        });
    }
    else {
        var parentNode = $cursor.parent;
        var cursorNodeIndex = $cursor.index();
        var mark = parentNode.child(cursorNodeIndex).marks.find(function (m) { return m.type === markType; });
        var childCount = parentNode.childCount;
        var markStart = $cursor.pos - $cursor.textOffset, markSize = parentNode.child(cursorNodeIndex).nodeSize, index = void 0, nodeSize = void 0;
        index = cursorNodeIndex - 1;
        while (index >= 0 && mark && mark.isInSet(parentNode.child(index).marks)) {
            nodeSize = parentNode.child(index).nodeSize;
            markSize += nodeSize;
            markStart -= nodeSize;
            index -= 1;
        }
        index = cursorNodeIndex + 1;
        while (index < childCount && mark.isInSet(parentNode.child(index).marks)) {
            markSize += parentNode.child(index).nodeSize;
            index += 1;
        }
        tr.removeMark(markStart, markStart + markSize, markType);
        tr.addMark(markStart, markStart + markSize, markType.create(attrs));
        dispatch(tr);
    }
}; };
/**
 * @hidden
 */
var addStyles = function (node, stylesToApply) {
    var currentStyles = node.attrs.style, changedStyleResult = null, toChange = null;
    if (currentStyles) {
        stylesToApply.forEach(function (style) {
            toChange = { style: style.name, value: /^.+$/, newValue: style.value };
            changedStyleResult = changeStyles(currentStyles, toChange);
            currentStyles = changedStyleResult.changed ? changedStyleResult.style : currentStyles;
        });
    }
    var reducer = function (acc, curr) { return ((acc && curr.value ? acc + ' ' : '') + curr.value ? curr.name + ": " + curr.value + ";" : ''); };
    currentStyles = currentStyles || stylesToApply.reduce(reducer, '');
    return Object.assign({}, node.attrs, { style: currentStyles || null });
};

/**
 * @hidden
 */
var indentRules = [
    {
        node: 'paragraph',
        step: 30,
        style: 'margin-left',
        unit: 'px'
    },
    {
        node: 'heading',
        step: 30,
        style: 'margin-left',
        unit: 'px'
    }
];
/**
 * @hidden
 */
var outdentRules = [
    {
        node: 'paragraph',
        step: -30,
        style: 'margin-left',
        unit: 'px'
    },
    {
        node: 'heading',
        step: -30,
        style: 'margin-left',
        unit: 'px'
    }
];

var _a = schema.nodes;
var bulletList = _a.bulletList;
var doc = _a.doc;
var listItem = _a.listItem;
var orderedList = _a.orderedList;
var getTypeName = function (n) {
    return n instanceof Node ? n.type.name : n.name;
};
var isListType = function (node) {
    var nodeName = typeof node === 'string' ? node : getTypeName(node);
    return nodeName === getTypeName(orderedList) || nodeName === getTypeName(bulletList);
};
var getListTypeFromPos = function (pos) {
    return Array.from(new Array(pos.depth), function (_, index) { return pos.depth - index; })
        .map(function (depth) { return pos.node(depth); })
        .map(getTypeName)
        .find(isListType);
};
var getNodeMarksOfType = function (markType, n) { return n.marks.filter(function (m) { return m.type.name === markType.name; }); };
var findParentNode = function (predicate) {
    return function (selection) {
        var $from = selection.$from;
        for (var i = $from.depth; i > 0; i--) {
            var node = $from.node(i);
            if (predicate(node)) {
                return { depth: i, node: node };
            }
        }
    };
};
var findNthParentNode = function (predicate, depth) {
    if (depth === void 0) { depth = 1; }
    return function (selection) {
        var $from = selection.$from;
        for (var i = $from.depth; i > 0; i--) {
            var node = $from.node(i);
            if (predicate(node)) {
                depth = depth - 1;
                if (depth === 0) {
                    return { depth: i, node: node };
                }
            }
        }
    };
};
var findNthParentNodeOfType = function (nodeType, depth) {
    if (depth === void 0) { depth = 1; }
    return function (selection) {
        return findNthParentNode(function (node) { return getTypeName(node) === getTypeName(nodeType); }, depth)(selection);
    };
};
/**
 * @hidden
 */
var getUniqueStyleValues = function (style, cssStyle) {
    if (style.hasNodesWithoutMarks) {
        return '';
    }
    var uniqueMarkValues = style.marks
        .filter(function (m) { return m.type.name === 'style'; })
        .map(function (m) { return m.attrs.style; })
        .map(split(';'))
        .map(filter$1(function (m) { return m.includes(cssStyle); }))
        // guards against empty array
        .map(function (cssStyleValues) { return (cssStyleValues.length !== 0 ? cssStyleValues : [cssStyle + ": INVALID"]); })
        .map(first)
        .map(split(':'))
        .map(last)
        .map(trim)
        .reduce(function (acc, curr) { return (acc.indexOf(curr) > -1 ? acc : acc.concat([curr])); }, []);
    if (uniqueMarkValues.indexOf('INVALID') > -1 || uniqueMarkValues.length !== 1) {
        return '';
    }
    return uniqueMarkValues[0];
};
/**
 * @hidden
 */
var isMarkActive = function (state, markType) {
    var _a = state.selection, from = _a.from, $from = _a.$from, to = _a.to, empty = _a.empty;
    if (empty) {
        return !!markType.isInSet(state.storedMarks || $from.marks());
    }
    else {
        return !!state.doc.rangeHasMark(from, to, markType);
    }
};
/**
 * @hidden
 */
var isNodeActive = function (state, nodeType, attrs) {
    var parent = findParentNode(function (node) { return getTypeName(node) === getTypeName(nodeType); })(state.selection);
    if (!parent || (attrs && !Object.keys(attrs).length)) {
        return !!parent;
    }
    return parent.node.hasMarkup(nodeType, attrs);
};
/**
 * @hidden
 */
var isInListOfType = function (_a, nodeType) {
    var selection = _a.selection;
    var $anchor = selection.$anchor, $head = selection.$head;
    var topNodes = [];
    var anchorParentName = getListTypeFromPos($anchor);
    var headParentName = getListTypeFromPos($head);
    selection.content().content.descendants(function (n) {
        topNodes = topNodes.concat([n]);
        return false;
    });
    var nonListTopNodes = topNodes.filter(function (n) {
        return getTypeName(n) !== getTypeName(bulletList) && getTypeName(n) !== getTypeName(orderedList);
    });
    // no selection
    if (selection instanceof TextSelection && selection.$cursor) {
        return getListTypeFromPos(selection.$cursor) === nodeType.name;
    }
    var hasSingleUniqueTopNode = unique(topNodes.map(getTypeName)).length === 1;
    // with selection
    if (nonListTopNodes.length > 0 || !hasSingleUniqueTopNode) {
        return false;
    }
    // from this point on we have guaranteed that the top nodes are all of the same LIST type
    // same top list node
    var node = first(topNodes);
    var listChildNodes = [getTypeName(node)];
    node.descendants(function (childNode) {
        if (isListType(childNode)) {
            listChildNodes = listChildNodes.concat([getTypeName(childNode)]);
        }
    });
    if (last(listChildNodes) !== nodeType.name) {
        return false;
    }
    return anchorParentName === headParentName && anchorParentName === nodeType.name;
};
/**
 * @hidden
 */
var getActiveMarks = function (_a, markType) {
    var selection = _a.selection;
    var hasNodesWithoutMarks = false;
    if (selection instanceof TextSelection && selection.$cursor) {
        return {
            hasNodesWithoutMarks: hasNodesWithoutMarks,
            marks: selection.$cursor.marks().filter(function (m) { return (markType ? m.type.name === markType.name : true); })
        };
    }
    var filtered = [];
    selection.content().content.descendants(function (n) {
        if (n.type.name === 'text') {
            var nodeMarksOfType = markType ? getNodeMarksOfType(markType, n) : n.marks;
            if (n.marks.length > 0 && nodeMarksOfType.length > 0) {
                filtered.push.apply(filtered, nodeMarksOfType);
            }
            else {
                hasNodesWithoutMarks = true;
            }
        }
    });
    return {
        hasNodesWithoutMarks: hasNodesWithoutMarks,
        marks: filtered
    };
};
/**
 * @hidden
 */
var getNodeTagName = function (node) {
    var parseRules = node.type.spec.parseDOM || [];
    var nodeAttrs = node.attrs;
    var parseRule;
    if (parseRules.length === 1) {
        parseRule = parseRules[0];
    }
    else {
        // TODO: refactor this
        // removeEmptyEntries is needed due to the default attributes in the schema
        parseRule = parseRules.find(function (rule) {
            // getAttrs needs a DOM Node
            var domNode = DOMSerializer.fromSchema(schema).serializeNode(node);
            return JSON.stringify(rule.getAttrs(domNode)) === JSON.stringify(removeEmptyEntries(nodeAttrs));
        });
    }
    if (parseRule) {
        // regex is needed since image node has tag = img[src]
        // https://stackoverflow.com/a/25777116
        return parseRule.tag.toLowerCase().replace(/ *\[[^\]]*]/, '');
    }
    else {
        return '';
    }
};
/**
 * @hidden
 */
var activeNode = function (state) {
    var isAllSelection = state.selection instanceof AllSelection;
    var isTextSelection = state.selection instanceof TextSelection;
    var isNodeSelection = state.selection instanceof NodeSelection;
    var isCellSelection = state.selection instanceof CellSelection;
    var node;
    if (isAllSelection) {
        node = state.doc;
    }
    else if (isTextSelection || isCellSelection) {
        var $anchor = state.selection.$anchor;
        var blockNode = $anchor.node($anchor.blockRange().depth);
        var isDoc = getTypeName(blockNode) === getTypeName(doc);
        node = isDoc ? $anchor.node() : blockNode;
    }
    else if (isNodeSelection) {
        var selection = state.selection;
        node = selection.node;
    }
    return {
        name: getTypeName(node),
        tag: getNodeTagName(node)
    };
};
/**
 * @hidden
 */
var canIndent = function (state, nodeType) {
    return isNodeActive(state, nodeType) && sinkListItem(nodeType)(state);
};
/**
 * @hidden
 */
var canOutdent = function (state, nodeType) {
    var isNestedInOL = !!findNthParentNodeOfType(orderedList, 2)(state.selection);
    var isNestedInUL = !!findNthParentNodeOfType(bulletList, 2)(state.selection);
    return isNodeActive(state, nodeType) && (isNestedInOL || isNestedInUL) && liftListItem(nodeType)(state);
};
/**
 * @hidden
 */
var getMark = function (state, markType) {
    var _a = state.selection, from = _a.from, $from = _a.$from, to = _a.to, empty = _a.empty;
    var stateDoc = state.doc;
    var mark;
    if (empty) {
        mark = markType.isInSet(state.storedMarks || $from.marks());
    }
    else {
        stateDoc.nodesBetween(from, to, function (node) {
            if (node.isInline && !mark) {
                mark = markType.isInSet(node.marks);
            }
        });
    }
    return mark;
};
/**
 * @hidden
 */
var getNodeFromSelection = function (state) {
    if (state.selection instanceof NodeSelection) {
        return state.selection.node;
    }
};
/**
 * @hidden
 */
var getSelectionText = function (state) {
    var sel = state.selection;
    if (sel instanceof TextSelection || sel instanceof AllSelection) {
        var fragment = sel.content().content;
        return fragment.textBetween(0, fragment.size);
    }
    return '';
};
/**
 * @hidden
 */
var getHTML = function (state) {
    var fragment = DOMSerializer.fromSchema(state.schema).serializeFragment(state.doc.content);
    var element = document.createElement('div');
    element.appendChild(fragment);
    return element.innerHTML;
};
/**
 * @hidden
 */
var createContentNode = function (value) {
    var element = document.createElement('div');
    // when using ngModel with name attr, content is null and errors, default params dont help
    element.innerHTML = safeString(value).trim();
    return DOMParser.fromSchema(schema).parse(element);
};
/**
 * @hidden
 */
var hasSameMarkup = function (dom1, dom2) {
    var fragment1 = Fragment.from(createContentNode(dom1));
    var fragment2 = Fragment.from(createContentNode(dom2));
    return fragment1.eq(fragment2);
};
/**
 * @hidden
 * Checks if the selection contains a specific type of node.
 */
var hasNode = function (state, nodeType) {
    var _a = state.selection, from = _a.from, to = _a.to;
    var result = false;
    state.doc.nodesBetween(from, to, function (node) {
        result = result || node.type === nodeType;
        return !result;
    });
    return result;
};
/**
 * @hidden
 */
var blockNodes = function (state) {
    var selection = state.selection;
    var from = selection.from, to = selection.to, $from = selection.$from;
    var result = [];
    if (selection.node) {
        if (selection.node.isBlock) {
            result.push(selection.node);
        }
        else if ($from.parent && $from.parent.isBlock) {
            result.push($from.parent);
        }
    }
    else {
        state.doc.nodesBetween(from, to, function (node) {
            if (node.isBlock) {
                result.push(node);
            }
        });
    }
    return result;
};
/**
 * @hidden
 * Checks if any block element in the selection is aligned.
 */
var isAligned = function (state, actions) {
    var blocks = blockNodes(state);
    var result = false;
    blocks.forEach(function (node) {
        if (!result && node.type.isTextblock && node.attrs.style) {
            var action = actions.find(function (a) { return a.node === node.type.name; });
            if (action) {
                result = action.style.every(function (style) {
                    return !!style.value && new RegExp(style.name + ":\\s?" + style.value, 'i').test(node.attrs.style);
                });
            }
        }
    });
    return result;
};
/**
 * @hidden
 * Checks if any block element in the selection is indented.
 */
var isIndented = function (state, actions) {
    var blocks = blockNodes(state);
    var result = false;
    blocks.forEach(function (node) {
        if (!result && node.type.isTextblock && node.attrs.style) {
            var action = actions.find(function (a) { return a.node === node.type.name; });
            if (action) {
                var reIndent = new RegExp(action.style + ":\\s?\\d+" + action.unit, 'i');
                result = reIndent.test(node.attrs.style);
            }
        }
    });
    return result;
};
/**
 * @hidden
 */
var canIndentAsListItem = function (state) { return sinkListItem(listItem)(state); };
/**
 * @hidden
 */
var canOutdentAsListItem = function (state) { return liftListItem(listItem)(state); };
/**
 * @hidden
 */
var canBeIndented = function (state, rules) {
    var nodes = state.schema.nodes;
    return ((isIndented(state, rules) || indentRules.some(function (rule) { return nodes[rule.node] && hasNode(state, nodes[rule.node]); })) &&
        !hasNode(state, listItem));
};

var _a$1 = schema.nodes;
var blockquote = _a$1.blockquote;
var heading = _a$1.heading;
var listItem$1 = _a$1.listItem;
var paragraph = _a$1.paragraph;
var image = _a$1.image;
/**
 * @hidden
 */
var removeMark = function (markType) { return function (state, dispatch) {
    var _a = state.selection, from = _a.from, to = _a.to, $cursor = _a.$cursor;
    if ($cursor) {
        var resolvedRange = getMarkRange($cursor, markType);
        dispatch(state.tr.removeMark(resolvedRange.from, resolvedRange.to, markType));
    }
    else {
        dispatch(state.tr.removeMark(from, to, markType));
    }
}; };
/**
 * @hidden
 */
var removeAllMarks = function (_a) {
    var _b = (_a === void 0 ? {} : _a).except, except = _b === void 0 ? [] : _b;
    return function (state, dispatch) {
        var _a = state.selection, $cursor = _a.$cursor, from = _a.from, to = _a.to;
        var tr = state.tr;
        var excludedMarkTypes = toArray(except).map(function (mt) { return mt.name; });
        if (!$cursor) {
            Object.keys(schema.marks)
                .map(function (m) { return schema.marks[m]; })
                .filter(function (mt) { return excludedMarkTypes.indexOf(mt.name) === -1; })
                .forEach(function (mt) { return tr.removeMark(from, to, mt); });
            dispatch(tr);
        }
    };
};
/**
 * @hidden
 */
var toggleBold = toggleMark(schema.marks.strong);
/**
 * @hidden
 */
var toggleItalic = toggleMark(schema.marks.em);
/**
 * @hidden
 */
var toggleUnderline = toggleMark(schema.marks.underline);
/**
 * @hidden
 */
var toggleStrikethrough = toggleMark(schema.marks.strikethrough);
/**
 * @hidden
 */
var toggleSubscript = toggleMark(schema.marks.subscript);
/**
 * @hidden
 */
var toggleSuperscript = toggleMark(schema.marks.superscript);
/**
 * @hidden
 */
var setFontFamily = function (font) { return function (state, dispatch) {
    var marks = state.schema.marks;
    var cmd = changeStyle(marks.style, {
        newValue: font,
        style: 'font-family',
        value: /^.+$/
    });
    return cmd(state, dispatch);
}; };
/**
 * @hidden
 */
var setFontSize = function (size) { return function (state, dispatch) {
    var marks = state.schema.marks;
    var cmd = changeStyle(marks.style, {
        newValue: size + "px",
        style: 'font-size',
        value: /^.+$/
    });
    return cmd(state, dispatch);
}; };
/**
 * @hidden
 */
var createLink = function (attrs) { return function (state, dispatch) {
    if (isMarkActive(state, schema.marks.link)) {
        modifyMark(schema.marks.link, attrs)(state, dispatch);
    }
    else if (state.selection.empty) {
        if (isDevMode() && !isPresent(attrs.text)) {
            throw new Error(
            // tslint:disable-next-line:max-line-length
            "Unable to create link without text. Please pass a 'text' property as part of the parameter or select any text in the Editor.");
        }
        var newLink = schema.text(attrs.text, [schema.marks.link.create(attrs)].concat(getActiveMarks(state).marks));
        dispatch(state.tr.replaceSelectionWith(newLink, false));
    }
    else {
        toggleMark(schema.marks.link, attrs)(state, dispatch);
    }
}; };
/**
 * @hidden
 */
var addOrUpdateStyle = function (cssProp, value) { return function (state, dispatch) {
    var marks = state.schema.marks;
    var selectionPresent = !state.selection.empty;
    if (selectionPresent || isMarkActive(state, marks.style)) {
        var cmd = changeStyle(marks.style, {
            style: cssProp,
            value: /^.+$/,
            newValue: value
        });
        cmd(state, dispatch);
    }
    else {
        var styles = marks.style.create({ style: cssProp + ": " + value });
        var transaction = state.tr.addStoredMark(styles);
        dispatch(transaction);
    }
}; };
/**
 * @hidden
 */
var applyHeading = function (level) { return setBlockType(heading, { level: level }); };
/**
 * @hidden
 */
var applyParagraph = setBlockType(paragraph);
/**
 * @hidden
 */
var applyBlockquote = setBlockType(blockquote);
/**
 * @hidden
 */
var format = function (_a) {
    var tag = _a.tag;
    if (tag.match(/h\d\b/)) {
        return applyHeading(parseInt(tag[1], 10));
    }
    else if (tag === 'p') {
        return applyParagraph;
    }
    else if (tag === 'blockquote') {
        return applyBlockquote;
    }
};
/**
 * @hidden
 */
var insertImage = function (attrs) { return function (state, dispatch) {
    var node = image.createAndFill(attrs);
    dispatch(state.tr.replaceSelectionWith(node));
}; };
/**
 * @hidden
 */
var insertText = function (attrs) { return function (state, dispatch) {
    dispatch(state.tr.insertText(attrs.text, attrs.from, attrs.to));
}; };
/**
 * @hidden
 */
var setHTML = function (content) { return function (state, dispatch) {
    return dispatch(state.tr.setSelection(new AllSelection(state.doc)).replaceSelectionWith(createContentNode(content)));
}; };
/**
 * @hidden
 * Aligning block elements in the selection.
 *
 * @returns {boolean} - Returns true if any alignment is applied.
 */
var alignBlocks = function (actions) { return function (state, dispatch) {
    var blocks = blockNodes(state);
    var tr = state.tr;
    var result = false;
    blocks.forEach(function (node) {
        if (node.type.isTextblock) {
            var newAttrs = {};
            var action = actions.find(function (n) { return n.node === node.type.name; });
            if (action) {
                newAttrs = addStyles(node, action.style);
            }
            result = changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;
        }
    });
    if (result) {
        dispatch(tr.scrollIntoView());
    }
    return result;
}; };
/**
 * Indenting block elements in the selection.
 *
 * @returns {boolean} - Returns true if any indentation is applied.
 */
var indentBlocks = function (actions) { return function (state, dispatch) {
    var blocks = blockNodes(state);
    var tr = state.tr;
    var result = false;
    blocks.forEach(function (node) {
        if (node.type.isTextblock) {
            var newAttrs = void 0;
            var action = actions.find(function (a) { return a.node === node.type.name; });
            if (action) {
                var newStyle = {
                    name: action.style,
                    value: action.step > 0 ? "" + action.step + action.unit : ''
                };
                if (node.attrs.style) {
                    var re = new RegExp(action.style + ":\\s?(\\d+)" + action.unit, 'i');
                    var match = node.attrs.style.match(re);
                    if (match) {
                        var newMargin = parseFloat(match[1]) + action.step;
                        newMargin = newMargin <= 0 ? '' : newMargin;
                        newStyle.value = "" + newMargin + (newMargin ? action.unit : '');
                    }
                }
                newAttrs = addStyles(node, [newStyle]);
            }
            if (newAttrs) {
                result = changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;
            }
        }
    });
    if (result) {
        dispatch(tr.scrollIntoView());
    }
    return result;
}; };
/**
 * @hidden
 */
var indent = function (state, dispatch) {
    var isIndentableBlock = canBeIndented(state, indentRules);
    if (canIndentAsListItem(state)) {
        sinkListItem(listItem$1)(state, dispatch);
    }
    else if (isIndentableBlock) {
        indentBlocks(indentRules)(state, dispatch);
    }
};
/**
 * @hidden
 */
var outdent = function (state, dispatch) {
    var isIndentableBlock = canBeIndented(state, outdentRules);
    if (canOutdentAsListItem(state)) {
        liftListItem(listItem$1)(state, dispatch);
    }
    else if (isIndentableBlock) {
        indentBlocks(outdentRules)(state, dispatch);
    }
};
/**
 * @hidden
 */
var insertNode = function (node, scrollIntoView) { return function (state, dispatch) {
    var tr = state.tr.replaceSelectionWith(node);
    if (scrollIntoView) {
        tr.scrollIntoView();
    }
    dispatch(tr);
}; };
/**
 * @hidden
 */
var createTable = function (nodes, rows, columns) {
    var table = nodes.table, table_row = nodes.table_row, table_cell = nodes.table_cell;
    var tableRows = [];
    var cells = [];
    for (var r = 0; r < rows + 1; r++) {
        cells.length = 0;
        for (var c = 0; c < columns + 1; c++) {
            cells.push(table_cell.createAndFill());
        }
        tableRows.push(table_row.createAndFill(undefined, cells));
    }
    return table.createAndFill(undefined, tableRows);
};
/**
 * @hidden
 */
var insertTable = function (attrs) { return function (state, dispatch) {
    var newTable = createTable(state.schema.nodes, attrs.rows, attrs.cols);
    if (newTable) {
        insertNode(newTable, true)(state, dispatch);
    }
}; };

var ɵ0$5 = function () { return toggleBold; };
var ɵ1$3 = function () { return removeAllMarks({ except: schema.marks.link }); };
var ɵ2$3 = function (attr) { return createLink(attr); };
var ɵ3$3 = function (font) { return setFontFamily(font); };
var ɵ4$3 = function (size) { return setFontSize(size); };
var ɵ5$2 = function (attr) { return createLink(attr); };
var ɵ6$2 = function (text) { return insertText(text); };
var ɵ7$2 = function () { return toggleItalic; };
var ɵ8$1 = function () { return toggleStrikethrough; };
var ɵ9$1 = function () { return toggleSubscript; };
var ɵ10$1 = function () { return toggleSuperscript; };
var ɵ11$1 = function () { return toggleUnderline; };
var ɵ12$1 = function () { return removeMark(schema.marks.link); };
var ɵ13$1 = function (color) { return addOrUpdateStyle('color', color); };
var ɵ14$1 = function (color) { return addOrUpdateStyle('background-color', color); };
var inlineCommand = {
    bold: ɵ0$5,
    cleanFormatting: ɵ1$3,
    createLink: ɵ2$3,
    fontFamily: ɵ3$3,
    fontSize: ɵ4$3,
    insertFile: ɵ5$2,
    insertText: ɵ6$2,
    italic: ɵ7$2,
    strikethrough: ɵ8$1,
    subscript: ɵ9$1,
    superscript: ɵ10$1,
    underline: ɵ11$1,
    unlink: ɵ12$1,
    foreColor: ɵ13$1,
    backColor: ɵ14$1
};
var ɵ15$1 = function () { return alignBlocks(alignCenterRules); };
var ɵ16$1 = function () { return alignBlocks(alignRemoveRules); };
var ɵ17$1 = function () { return alignBlocks(alignLeftRules); };
var ɵ18$1 = function () { return alignBlocks(alignRightRules); };
var ɵ19$1 = function (formatAttr) { return format(formatAttr); };
var ɵ20$1 = function () { return getHTML; };
var ɵ21$1 = function () { return indent; };
var ɵ22$1 = function (attrs) { return insertImage(attrs); };
var ɵ23$1 = function () { return toggleOrderedList; };
var ɵ24$1 = function () { return toggleUnorderedList; };
var ɵ25$1 = function () { return outdent; };
var ɵ26$1 = function () { return redo; };
var ɵ27$1 = function (content) { return setHTML(content); };
var ɵ28$1 = function () { return undo; };
var blockCommand = {
    alignCenter: ɵ15$1,
    alignJustify: ɵ16$1,
    alignLeft: ɵ17$1,
    alignRight: ɵ18$1,
    format: ɵ19$1,
    getHTML: ɵ20$1,
    indent: ɵ21$1,
    insertImage: ɵ22$1,
    // think about changing the command name.
    insertOrderedList: ɵ23$1,
    // think about changing the command name.
    insertUnorderedList: ɵ24$1,
    outdent: ɵ25$1,
    redo: ɵ26$1,
    setHTML: ɵ27$1,
    undo: ɵ28$1
};
var ɵ29$1 = function (attr) { return insertTable(attr); };
var ɵ30$1 = function () { return addColumnBefore; };
var ɵ31$1 = function () { return addColumnAfter; };
var ɵ32 = function () { return addRowBefore; };
var ɵ33 = function () { return addRowAfter; };
var ɵ34 = function () { return deleteRow; };
var ɵ35 = function () { return deleteColumn; };
var ɵ36 = function () { return mergeCells; };
var ɵ37 = function () { return splitCell; };
var ɵ38 = function () { return deleteTable; };
var tableCommand = {
    insertTable: ɵ29$1,
    addColumnBefore: ɵ30$1,
    addColumnAfter: ɵ31$1,
    addRowBefore: ɵ32,
    addRowAfter: ɵ33,
    deleteRow: ɵ34,
    deleteColumn: ɵ35,
    mergeCells: ɵ36,
    splitCell: ɵ37,
    deleteTable: ɵ38
};
/**
 * @hidden
 */
var editorCommands = Object.assign({}, inlineCommand, blockCommand, tableCommand);

/**
 * @hidden
 */
var EditorLocalizationService = /** @class */ (function (_super) {
    __extends(EditorLocalizationService, _super);
    function EditorLocalizationService(prefix, messageService, _rtl) {
        return _super.call(this, prefix, messageService, _rtl) || this;
    }
    /** @nocollapse */
    EditorLocalizationService.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Inject, args: [L10N_PREFIX,] }] },
        { type: MessageService, decorators: [{ type: Optional }] },
        { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] }] }
    ]; };
    return EditorLocalizationService;
}(LocalizationService));

// import { EditorService } from '../editor.service';
/**
 * @hidden
 */
var SourceDialogComponent = /** @class */ (function (_super) {
    __extends(SourceDialogComponent, _super);
    function SourceDialogComponent(dialog, localization) {
        var _this = _super.call(this, dialog) || this;
        _this.dialog = dialog;
        _this.localization = localization;
        _this.data = '';
        return _this;
    }
    SourceDialogComponent.prototype.onCancelAction = function () {
        this.dialog.close();
    };
    SourceDialogComponent.prototype.onConfirmAction = function () {
        this.editor.exec('setHTML', this.getData());
        this.dialog.close();
        this.editor.focus();
    };
    SourceDialogComponent.prototype.getData = function () {
        return this.textarea.nativeElement.value;
    };
    SourceDialogComponent.prototype.setData = function () {
        this.data = this.indent(this.editor.getSource());
    };
    SourceDialogComponent.prototype.textFor = function (key) {
        return this.localization.get(key);
    };
    SourceDialogComponent.prototype.indent = function (content) {
        return content
            .replace(/<\/(p|li|ul|ol|h[1-6]|table|tr|td|th)>/gi, '</$1>\n')
            .replace(/<(ul|ol)([^>]*)><li/gi, '<$1$2>\n<li')
            .replace(/<br \/>/gi, '<br />\n')
            .replace(/\n$/, '');
    };
    SourceDialogComponent.decorators = [
        { type: Component, args: [{
                    styles: [
                        "\n            >>> .k-editor-textarea {\n                height: 100%;\n            }\n        "
                    ],
                    template: "\n        <kendo-dialog-titlebar>\n            {{ textFor('viewSource') }}\n        </kendo-dialog-titlebar>\n        <textarea [value]=\"data\" #textarea class=\"k-editor-textarea k-input\"></textarea>\n        <kendo-dialog-actions>\n            <button kendoButton (click)=\"onCancelAction()\">{{ textFor('dialogCancel') }}</button>\n            <button kendoButton (click)=\"onConfirmAction()\" [primary]=\"true\">{{ textFor('dialogUpdate') }}</button>\n        </kendo-dialog-actions>\n    "
                },] },
    ];
    /** @nocollapse */
    SourceDialogComponent.ctorParameters = function () { return [
        { type: DialogRef },
        { type: EditorLocalizationService }
    ]; };
    SourceDialogComponent.propDecorators = {
        editor: [{ type: Input }],
        textarea: [{ type: ViewChild, args: ['textarea',] }]
    };
    return SourceDialogComponent;
}(DialogContentBase));

/**
 * @hidden
 */
var ImageDialogComponent = /** @class */ (function (_super) {
    __extends(ImageDialogComponent, _super);
    function ImageDialogComponent(dialog, localization) {
        var _this = _super.call(this, dialog) || this;
        _this.dialog = dialog;
        _this.localization = localization;
        _this.src = new FormControl('', Validators.required);
        _this.alt = new FormControl('');
        _this.width = new FormControl('', Validators.min(1));
        _this.height = new FormControl('', Validators.min(1));
        _this.data = {
            alt: '',
            height: '',
            src: '',
            width: ''
        };
        _this.imageData = new FormGroup({
            alt: _this.alt,
            height: _this.height,
            src: _this.src,
            width: _this.width
        });
        return _this;
    }
    ImageDialogComponent.prototype.onCancelAction = function () {
        this.dialog.close();
    };
    ImageDialogComponent.prototype.onConfirmAction = function () {
        if (this.src.value) {
            this.editor.exec('insertImage', this.getData());
            this.dialog.close();
            this.editor.focus();
        }
    };
    ImageDialogComponent.prototype.setData = function (state) {
        var node = getNodeFromSelection(state);
        if (node) {
            this.src.patchValue(node.attrs.src);
            this.alt.patchValue(node.attrs.alt);
            this.width.patchValue(node.attrs.width);
            this.height.patchValue(node.attrs.height);
        }
    };
    ImageDialogComponent.prototype.textFor = function (key) {
        return this.localization.get(key);
    };
    ImageDialogComponent.prototype.getData = function () {
        return {
            alt: this.alt.value,
            height: this.normalizeDimension(this.height.value),
            src: this.src.value,
            width: this.normalizeDimension(this.width.value)
        };
    };
    ImageDialogComponent.prototype.normalizeDimension = function (value) {
        return Number.isNaN(parseInt(value, 10)) || parseInt(value, 10) <= 0 ? '' : safeString(parseInt(value, 10));
    };
    ImageDialogComponent.decorators = [
        { type: Component, args: [{
                    template: "\n        <kendo-dialog-titlebar>\n            {{ textFor('insertImage') }}\n        </kendo-dialog-titlebar>\n        <div class=\"k-editor-dialog\">\n            <div class=\"k-editor-dialog k-popup-edit-form k-window-content k-content\">\n                <div class=\"k-edit-form-container k-window-content\">\n                    <div class=\"k-edit-label\">\n                        <label for=\"k-editor-image-url\">{{ textFor('imageWebAddress') }}</label>\n                    </div>\n                    <div class=\"k-edit-field\">\n                        <input [formControl]=\"src\" type=\"text\" class=\"k-input k-textbox\" />\n                    </div>\n                    <div class=\"k-edit-label\">\n                        <label for=\"k-editor-image-text\">{{ textFor('imageAltText') }}</label>\n                    </div>\n                    <div class=\"k-edit-field\">\n                        <input [formControl]=\"alt\" type=\"text\" class=\"k-input k-textbox\" />\n                    </div>\n                    <div class=\"k-edit-label\">\n                        <label for=\"k-editor-image-width\">{{ textFor('imageWidth') }}</label>\n                    </div>\n                    <div class=\"k-edit-field\">\n                        <input [formControl]=\"width\" type=\"text\" class=\"k-input k-textbox\" />\n                    </div>\n                    <div class=\"k-edit-label\">\n                        <label for=\"k-editor-image-height\">{{ textFor('imageHeight') }}</label>\n                    </div>\n                    <div class=\"k-edit-field\">\n                        <input [formControl]=\"height\" type=\"text\" class=\"k-input k-textbox\" />\n                    </div>\n                </div>\n            </div>\n        </div>\n        <kendo-dialog-actions>\n            <button kendoButton (click)=\"onCancelAction()\">{{ textFor('dialogCancel') }}</button>\n            <button kendoButton [disabled]=\"imageData.invalid\"\n                    (click)=\"onConfirmAction()\" [primary]=\"true\">{{ textFor('dialogInsert') }}</button>\n        </kendo-dialog-actions>\n    "
                },] },
    ];
    /** @nocollapse */
    ImageDialogComponent.ctorParameters = function () { return [
        { type: DialogRef },
        { type: EditorLocalizationService }
    ]; };
    ImageDialogComponent.propDecorators = {
        editor: [{ type: Input }]
    };
    return ImageDialogComponent;
}(DialogContentBase));

/**
 * @hidden
 */
var FileLinkDialogComponent = /** @class */ (function (_super) {
    __extends(FileLinkDialogComponent, _super);
    function FileLinkDialogComponent(dialog, localization) {
        var _this = _super.call(this, dialog) || this;
        _this.dialog = dialog;
        _this.localization = localization;
        _this.linkForm = new FormGroup({
            'href': new FormControl('', Validators.required),
            'text': new FormControl('', Validators.required),
            'title': new FormControl('')
        });
        return _this;
    }
    FileLinkDialogComponent.prototype.onCancelAction = function () {
        this.dialog.close();
    };
    FileLinkDialogComponent.prototype.onConfirmAction = function () {
        var linkData = this.getData();
        this.editor.exec(this.command, linkData);
        this.dialog.close();
        this.editor.focus();
    };
    Object.defineProperty(FileLinkDialogComponent.prototype, "titleText", {
        get: function () {
            return this.localization.get(this.command);
        },
        enumerable: true,
        configurable: true
    });
    FileLinkDialogComponent.prototype.setData = function (state) {
        if (this.command === 'createLink') {
            this.linkForm.addControl('target', new FormControl());
        }
        var linkMark = getMark(state, schema.marks.link);
        if (linkMark) {
            // const linkMarkRange = getMarkRange(state.selection.$cursor, schema.marks.link);
            // const mark = parentNode.child(cursorNodeIndex).marks.find(m => m.type === markType);
            this.linkForm.reset({
                href: linkMark.attrs.href,
                title: linkMark.attrs.title,
                target: isPresent(linkMark.attrs.target),
                text: this.setLinkText(state)
            });
            return;
        }
        if (!state.selection.empty) {
            this.linkForm.patchValue({
                'text': getSelectionText(state)
            });
        }
    };
    FileLinkDialogComponent.prototype.textForWithPrefix = function (key) {
        var prefix = this.command === 'createLink' ? 'link' : 'file';
        return this.textFor(prefix + key);
    };
    FileLinkDialogComponent.prototype.textFor = function (key) {
        return this.localization.get(key);
    };
    FileLinkDialogComponent.prototype.setLinkText = function (state) {
        var selection = state.selection;
        if (selection.empty && selection.$cursor) {
            var cursor = selection.$cursor;
            var cursorNodeIndex = cursor.index();
            var parentNode = cursor.parent;
            return parentNode.child(cursorNodeIndex).text;
        }
        else {
            return getSelectionText(state);
        }
    };
    FileLinkDialogComponent.prototype.getData = function () {
        var linkData = this.linkForm.value;
        if (isPresent(this.linkForm.controls.target)) {
            linkData.target = linkData.target ? '_blank' : null;
        }
        return linkData;
    };
    FileLinkDialogComponent.decorators = [
        { type: Component, args: [{
                    template: "\n        <kendo-dialog-titlebar>\n            {{ titleText }}\n        </kendo-dialog-titlebar>\n        <div class='k-editor-dialog'>\n            <div class='k-editor-dialog k-popup-edit-form k-window-content k-content'>\n                <div class='k-edit-form-container k-window-content'>\n                    <form novalidate [formGroup]='linkForm'>\n                        <div class='k-edit-label'>\n                            <label (click)='hrefInput.focus()'>{{ textForWithPrefix('WebAddress') }}</label>\n                        </div>\n                        <div class='k-edit-field'>\n                            <input #hrefInput formControlName='href' type='text' class='k-input k-textbox'>\n                        </div>\n\n                        <div class='k-edit-label'>\n                            <label (click)='textInput.focus()'>{{ textForWithPrefix('Text') }}</label>\n                        </div>\n                        <div class='k-edit-field'>\n                            <input #textInput formControlName='text' type='text' class='k-input k-textbox'>\n                        </div>\n\n                        <div class='k-edit-label'>\n                            <label (click)='titleInput.focus()'>{{ textForWithPrefix('Title') }}</label>\n                        </div>\n                        <div class='k-edit-field'>\n                            <input #titleInput formControlName='title' type='text' class='k-input k-textbox'>\n                        </div>\n                        <ng-container *ngIf=\"command === 'createLink'\">\n                            <div class='k-edit-label'></div>\n                            <div class='k-edit-field'>\n                                <input type='checkbox' id='k-target-blank' class='k-checkbox' formControlName='target'>\n                                <label class='k-checkbox-label' for='k-target-blank'>{{ textForWithPrefix('OpenInNewWindow') }}</label>\n                            </div>\n                        </ng-container>\n                    </form>\n                </div>\n            </div>\n        </div>\n        <kendo-dialog-actions>\n            <button kendoButton (click)='onCancelAction()'>{{ textFor('dialogCancel') }}</button>\n            <button kendoButton [disabled]='linkForm.invalid'\n                    (click)='onConfirmAction()' [primary]='true'>{{ textFor('dialogInsert') }}</button>\n        </kendo-dialog-actions>\n    "
                },] },
    ];
    /** @nocollapse */
    FileLinkDialogComponent.ctorParameters = function () { return [
        { type: DialogRef },
        { type: EditorLocalizationService }
    ]; };
    FileLinkDialogComponent.propDecorators = {
        editor: [{ type: Input }],
        command: [{ type: Input }]
    };
    return FileLinkDialogComponent;
}(DialogContentBase));

/**
 * @hidden
 */
var getToolbarState = function (state) { return ({
    alignCenter: isAligned(state, alignCenterRules),
    alignJustify: isAligned(state, alignRemoveRules),
    alignLeft: isAligned(state, alignLeftRules),
    alignRight: isAligned(state, alignRightRules),
    bold: isMarkActive(state, schema.marks.strong),
    cleanFormatting: state.selection.empty,
    format: activeNode(state),
    indent: canIndent(state, schema.nodes.listItem) || canBeIndented(state, indentRules),
    insertOrderedList: isInListOfType(state, schema.nodes.orderedList),
    insertUnorderedList: isInListOfType(state, schema.nodes.bulletList),
    italic: isMarkActive(state, schema.marks.em),
    link: isMarkActive(state, schema.marks.link),
    noSelection: state.selection.empty,
    outdent: canOutdent(state, schema.nodes.listItem) || canBeIndented(state, outdentRules),
    redo: !redo(state),
    strikethrough: isMarkActive(state, schema.marks.strikethrough),
    style: getActiveMarks(state, schema.marks.style),
    subscript: isMarkActive(state, schema.marks.subscript),
    superscript: isMarkActive(state, schema.marks.superscript),
    underline: isMarkActive(state, schema.marks.underline),
    undo: !undo(state),
    insertTable: false,
    addColumnBefore: !addColumnBefore(state),
    addColumnAfter: !addColumnAfter(state),
    addRowBefore: !addRowBefore(state),
    addRowAfter: !addRowAfter(state),
    deleteRow: !deleteRow(state),
    deleteColumn: !deleteColumn(state),
    mergeCells: !mergeCells(state),
    splitCell: !splitCell(state),
    deleteTable: !deleteTable(state)
}); };
/**
 * @hidden
 */
var initialToolBarState = {
    //marks
    bold: false,
    italic: false,
    underline: false,
    strikethrough: false,
    unlink: true,
    subscript: false,
    superscript: false,
    style: { marks: [], hasNodesWithoutMarks: false },
    //nodes
    format: { text: 'Format', tag: null },
    insertOrderedList: false,
    insertUnorderedList: false,
    indent: false,
    outdent: false,
    alignLeft: false,
    alignCenter: false,
    alignRight: false,
    alignJustify: false,
    //history
    undo: true,
    redo: true,
    //selection
    noSelection: true,
    cleanFormatting: true,
    //table
    insertTable: false,
    addColumnBefore: true,
    addColumnAfter: true,
    addRowBefore: true,
    addRowAfter: true,
    deleteRow: true,
    deleteColumn: true,
    mergeCells: true,
    splitCell: true,
    deleteTable: true
};

/**
 * @hidden
 */
var defaultStyle = "\nhtml, body {\n    margin: 0;\n    height: 100%;\n    padding: 0;\n}\n\nhtml {\n  min-height: 100%;\n}\n\nbody {\n  box-sizing: border-box;\n  position: relative;\n  word-wrap: break-word;\n  padding: 8px;\n}\n\nbody > .k-content {\n  outline: 0;\n  height: 100%;\n}\n\n.k-content > p {\n  margin: 0 0 1em;\n}\n\n.k-content .ProseMirror-selectednode {\n  outline: 2px solid #8cf;\n}\n\ndiv.ProseMirror {\n  height: 100%;\n}\n\ndiv.ProseMirror:focus {\n  outline: none;\n}\n\n.ProseMirror-hideselection *::selection { background: transparent; }\n.ProseMirror-hideselection *::-moz-selection { background: transparent; }\n.ProseMirror-hideselection { caret-color: transparent; }\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n";
/**
 * @hidden
 */
var tablesStyles = "\n  .ProseMirror .tableWrapper {\n    overflow-x: auto;\n    margin: 1em 0;\n  }\n\n  .ProseMirror table {\n    margin: 0;\n    border-collapse: collapse;\n    table-layout: fixed;\n    width: 100%;\n    overflow: hidden;\n  }\n\n  .ProseMirror td, .ProseMirror th {\n    min-width: 1em;\n    border: 1px solid #ddd;\n    padding: 3px 5px;\n    vertical-align: top;\n    box-sizing: border-box;\n    position: relative;\n  }\n\n  .ProseMirror th {\n    font-weight: bold;\n    text-align: left;\n  }\n\n  .ProseMirror .column-resize-handle {\n    position: absolute;\n    right: -2px; top: 0; bottom: 0;\n    width: 4px;\n    z-index: 20;\n    background-color: #adf;\n    pointer-events: none;\n  }\n\n  .ProseMirror.resize-cursor {\n    cursor: ew-resize;\n    cursor: col-resize;\n  }\n\n  /* Give selected cells a blue overlay */\n  .ProseMirror .selectedCell:after {\n    z-index: 2;\n    position: absolute;\n    content: \"\";\n    left: 0; right: 0; top: 0; bottom: 0;\n    background: rgba(200, 200, 255, 0.4);\n    pointer-events: none;\n  }\n";
/**
 * @hidden
 */
var rtlStyles = 'body { direction: rtl }';

var EMPTY_PARAGRAPH = '<p></p>';
var firefox = isDocumentAvailable() ? /Firefox/.test(navigator.userAgent) : false;
/**
 * Represents the [Kendo UI Editor component for Angular]({% slug overview_editor %}).
 */
var EditorComponent = /** @class */ (function () {
    function EditorComponent(dialogService, localization, cdr, ngZone) {
        this.dialogService = dialogService;
        this.localization = localization;
        this.cdr = cdr;
        this.ngZone = ngZone;
        /**
         * If set to `false`, the Editor will run in style non-encapsulated mode. This means
         * that the styles of the page will be persisted in the Editor and its content will be affected by them.
         */
        this.iframe = true;
        /**
         * By design, the Editor emits `valueChange`, updates the model and the ToolBar state on each keystroke.
         * When you are interested in ignoring the new values for a given amout of time and take only the most recent one, you can use the `updateInterval` property.
         * A possible use case is to get the new values and to update the ToolBar state at a maximum rate per second in order to speed up your application.
         * The specified interval (in milliseconds) should be a positive number.
         * By default the `updateInterval` is set to 100 miliseconds. If set to zero the delay will be disabled entirely.
         */
        this.updateInterval = 100;
        /**
         * Fires each time the value of the Editor is changed upon user interaction&mdash;
         * for example, when the component is blurred or the value is updated through the `viewSource` dialog.
         * When the value of the Editor is programmatically changed through its API (`ngModel`) or form binding (`formControl`),
         * the `valueChange` event is not triggered because it might cause a mix-up with the
         * built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.valueChange = new EventEmitter();
        this.hostClasses = true;
        /**
         * @hidden
         */
        this.stateChange = new BehaviorSubject(initialToolBarState);
        /**
         * @hidden
         */
        this.valueModified = new Subject();
        this.onChangeCallback = function (_) { }; // tslint:disable-line:no-empty
        this.onTouchedCallback = function (_) { }; // tslint:disable-line:no-empty
        this.direction = localization.rtl ? 'rtl' : 'ltr';
    }
    Object.defineProperty(EditorComponent.prototype, "value", {
        get: function () {
            var value = this.view ? this.getSource() : this._value;
            if (value === EMPTY_PARAGRAPH) {
                return this._value ? '' : this._value;
            }
            else {
                return value;
            }
        },
        /**
         * Sets the value of the Editor ([see example]({% slug overview_editor %}#toc-basic-usage)).
         */
        set: function (value) {
            this._value = value;
            this._previousValue = value;
            if (this.view) {
                this.exec('setHTML', this._value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorComponent.prototype, "isIE", {
        get: function () {
            return this.iframe && detectIE();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorComponent.prototype, "dir", {
        get: function () {
            return this.direction;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorComponent.prototype, "toolbar", {
        get: function () {
            return this.defaultToolbarComponent || this.userToolBarComponent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorComponent.prototype, "shouldInitOnLoad", {
        get: function () {
            //should init onload when the browser is firefox and content is in an iframe
            return firefox && this.iframe;
        },
        enumerable: true,
        configurable: true
    });
    EditorComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.subs = this.localization.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.direction = rtl ? 'rtl' : 'ltr';
        });
    };
    EditorComponent.prototype.ngAfterViewInit = function () {
        if (!this.shouldInitOnLoad) {
            this.initialize();
        }
    };
    /**
     * @hidden
     */
    EditorComponent.prototype.iframeOnLoad = function () {
        if (this.shouldInitOnLoad) {
            this.initialize();
        }
    };
    /**
     * Executes a command on the currently selected text
     * ([more information and example]({% slug toolbartools_editor %}#toc-custom-tools)).
     *
     * @param {EditorCommand} commandName - The command that will be executed.
     * @param {any} attr - Optional parameters for the command. Apart from the following list,
     * the parameters do not expect specific attributes when you call them:
     * - `format` - Accepts an object with the `tag` property.
     * The supported tags are `p`, `blockquote`, and any of the `h1` to `h6` heading tags.
     * - `createLink` - Accepts an object with the `href`, `title`, and `target` properties. The `href` property is mandatory.
     * - `setHTML` - Accepts a `string` parameter.
     * - `insertTable` - Accepts an object with the `rows` and `cols` properties. The number values are zero based.
     *
     * @example
     * ```ts-no-run
     * // Toggles the bold styling.
     * editor.exec('bold');
     *
     * // Creates a bullet list.
     * editor.exec('insertUnorderedList');
     *
     * // Creates a link.
     * editor.exec('createLink', { href: 'www.progress.com', title: 'Progress', target: 'window' });
     *
     * // Inserts a file.
     * editor.exec('insertFile', { href: 'www.progress.com/resources/myfile.doc', title: 'My file', target: 'window' });
     *
     * // Inserts a image.
     * editor.exec('insertImage', { src: 'www.progress.com/resources/logo.jpg', title: 'Progress', target: 'window' });
     *
     * // Inserts a text at a given position. If no position is specified, the text will be inserted after the cursor.
     * editor.exec('insertText', { text: 'Hello World!', from: 0, to: 0 });
     *
     * // Changes the format of a text block.
     * editor.exec('format', { tag: 'h2' });
     *
     * // Changes the font size of the selected text.
     * editor.exec('fontSize', 24);
     *
     * // Changes the content of the Editor.
     * editor.exec('setHTML', '<p>HTML content</p>');
     *
     * // Creates and inserts a table with the specified number of rows and columns. Numbers are zero based.
     * this.editor.exec("insertTable", { rows: 3, cols: 5 });
     * ```
     */
    EditorComponent.prototype.exec = function (commandName, attr) {
        // Finds a command and applies the attributes.
        var command = editorCommands[commandName](attr);
        // Executes a ProseMirror command.
        command(this.view.state, this.view.dispatch, this.view);
        // See the `dispatchTransaction` comments.
        // this.stateChange.emit(updateToolBar(this.view));
    };
    /**
     * Opens a dialog.
     * @param {DialogCommand} dialogName - The name of the dialog that will open.
     *
     * The supported values are:
     * * `createLink`
     * * `viewSource`
     * * `insertFile`
     * * `insertImage`
     * * `tableWizard`
     *
     * @example
     * ```ts-no-run
     * // Opens a `createLink` dialog.
     * editor.openDialog('createLink');
     *
     * // Opens a `viewSource` dialog.
     * editor.exec('viewSource');
     * ```
     */
    EditorComponent.prototype.openDialog = function (dialogName) {
        var editorDialogs = {
            createLink: {
                content: FileLinkDialogComponent
            },
            insertFile: {
                content: FileLinkDialogComponent
            },
            insertImage: {
                content: ImageDialogComponent
            },
            viewSource: {
                content: SourceDialogComponent,
                height: 400,
                width: 500
            }
            // tableWizard: {
            //     content: TableWizardDialogComponent
            // }
        };
        var dialog = Object.assign({ appendTo: this.dialogContainer }, editorDialogs[dialogName]);
        this.toolbar.toggle(false);
        var dialogContent = this.dialogService.open(dialog).content.instance;
        if (dialogName === 'createLink' || dialogName === 'insertFile') {
            dialogContent.command = dialogName;
        }
        dialogContent.editor = this;
        dialogContent.setData(this.view.state);
    };
    /**
     * Manually focus the Editor.
     */
    EditorComponent.prototype.focus = function () {
        this.view.focus();
    };
    /**
     * Manually blur the Editor.
     */
    EditorComponent.prototype.blur = function () {
        this.view.dom.blur();
    };
    /**
     * @hidden
     */
    EditorComponent.prototype.getSource = function () {
        return getHTML(this.view.state);
    };
    EditorComponent.prototype.ngOnDestroy = function () {
        this.subs.unsubscribe();
    };
    /**
     * @hidden
     */
    EditorComponent.prototype.writeValue = function (value) {
        // To avoid confusion, non-existent values are always undefined.
        this.value = value === null ? undefined : value;
    };
    /**
     * @hidden
     */
    EditorComponent.prototype.registerOnChange = function (fn) {
        this.onChangeCallback = fn;
    };
    /**
     * @hidden
     */
    EditorComponent.prototype.registerOnTouched = function (fn) {
        this.onTouchedCallback = fn;
    };
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty.
     */
    EditorComponent.prototype.isEmpty = function () {
        return false;
    };
    EditorComponent.prototype.initialize = function () {
        var _this = this;
        if (!isDocumentAvailable()) {
            return;
        }
        var that = this;
        var containerNativeElement = this.container.element.nativeElement;
        var contentNode = createContentNode(this.value);
        if (this.iframe) {
            var iframeDoc_1 = containerNativeElement.contentDocument;
            var meta = iframeDoc_1.createElement('meta');
            meta.setAttribute('charset', 'utf-8');
            iframeDoc_1.head.appendChild(meta);
            [
                defaultStyle,
                tablesStyles,
                this.dir === 'rtl' ? rtlStyles : undefined
            ].forEach(function (styles) {
                if (styles) {
                    var style = iframeDoc_1.createElement('style');
                    style.appendChild(iframeDoc_1.createTextNode(styles));
                    iframeDoc_1.head.appendChild(style);
                }
            });
            var element = iframeDoc_1.createElement('div');
            iframeDoc_1.body.appendChild(element);
        }
        else {
            var element = document.createElement('div');
            containerNativeElement.appendChild(element);
        }
        var state = EditorState.create({
            schema: schema,
            doc: contentNode,
            plugins: [
                history(),
                keymap(buildListKeymap(schema)),
                keymap(buildKeymap(schema)),
                keymap(baseKeymap)
            ]
        });
        if (this.iframe) {
            this.viewMountElement = containerNativeElement.contentDocument.querySelector('div');
        }
        else {
            this.viewMountElement = containerNativeElement.querySelector('div');
        }
        this.ngZone.runOutsideAngular(function () {
            _this.view = new EditorView({ mount: _this.viewMountElement }, {
                state: state,
                dispatchTransaction: function (tr) {
                    // `this` is bound to the view instance.
                    this.updateState(this.state.apply(tr));
                    that.stateChange.next(getToolbarState(this.state));
                    // that.cdr.detectChanges();
                    // When the user utilizes keyboard shortcuts&mdash;for example, `Ctrl`+`b`&mdash;
                    // `tr.docChanged` is `true` and the toolbar is not updated.
                    // A possible future solution is to move the keymaps to the service.
                    // if (!tr.docChanged) {
                    //     that.stateChange.emit(updateToolBar(that.view));
                    // }
                    var value = that.value;
                    if (!hasSameMarkup(value, that._previousValue)) {
                        that._previousValue = value;
                        that.ngZone.run(function () { return that.valueModified.next(value); });
                    }
                }
            });
        });
        this.subs.add(merge(this.stateChange.pipe(filter(function () { return _this.updateInterval > 0; }), auditTime(this.updateInterval)), this.stateChange.pipe(filter(function () { return _this.updateInterval === 0; })))
            .subscribe(function () {
            if (_this.userToolBarComponent) {
                _this.userToolBarComponent.cdr.detectChanges();
            }
            else {
                _this.cdr.detectChanges();
            }
        }));
        this.subs.add(merge(this.valueModified.pipe(filter(function () { return _this.updateInterval > 0; }), auditTime(this.updateInterval)), this.valueModified.pipe(filter(function () { return _this.updateInterval === 0; })))
            .subscribe(function (value) {
            that.onChangeCallback(value);
            _this.valueChange.emit(value);
        }));
        this.subs.add(fromEvent(this.viewMountElement, 'keyup').pipe(map(function (e) { return e.keyCode; }), filter(function (code) { return code === 121; }), // F10
        map(function () { return _this.userToolBarElement || _this.defaultToolbar; }))
            .subscribe(function (toolbar) { return toolbar.nativeElement.focus(); }));
        this.subs.add(fromEvent(this.viewMountElement, 'blur').pipe(filter(function (event) { return !_this.viewMountElement.contains(event.relatedTarget); }))
            .subscribe(function () { return _this.onTouchedCallback(); }));
    };
    EditorComponent.decorators = [
        { type: Component, args: [{
                    selector: 'kendo-editor',
                    providers: [
                        EditorLocalizationService,
                        {
                            provide: LocalizationService,
                            useExisting: EditorLocalizationService
                        },
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.editor'
                        },
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(function () { return EditorComponent; }),
                            multi: true
                        },
                        {
                            provide: KendoInput,
                            useExisting: forwardRef(function () { return EditorComponent; })
                        }
                    ],
                    /* tslint:disable:max-line-length */
                    template: "\n        <ng-container kendoEditorLocalizedMessages\n            i18n-alignCenter=\"kendo.editor.alignCenter|The title of the tool that aligns text in the center.\"\n            alignCenter=\"Center text\"\n\n            i18n-alignJustify=\"kendo.editor.alignJustify|The title of the tool that justifies text both left and right.\"\n            alignJustify=\"Justify\"\n\n            i18n-alignLeft=\"kendo.editor.alignLeft|The title of the tool that aligns text on the left.\"\n            alignLeft=\"Align text left\"\n\n            i18n-alignRight=\"kendo.editor.alignRight|The title of the tool that aligns text on the right.\"\n            alignRight=\"Align text right\"\n\n            i18n-backColor=\"kendo.editor.backColor|The title of the tool that changes the text background color.\"\n            backColor=\"Background color\"\n\n            i18n-bold=\"kendo.editor.bold|The title of the tool that makes text bold.\"\n            bold=\"Bold\"\n\n            i18n-cleanFormatting=\"kendo.editor.cleanFormatting|The title of the Clean Formatting tool.\"\n            cleanFormatting=\"Clean formatting\"\n\n            i18n-createLink=\"kendo.editor.createLink|The title of the tool that creates hyperlinks.\"\n            createLink=\"Insert link\"\n\n            i18n-dialogApply=\"kendo.editor.dialogApply|The label of the **Apply** button in all editor dialogs.\"\n            dialogApply=\"Apply\"\n\n            i18n-dialogCancel=\"kendo.editor.dialogCancel|The label of the **Cancel** button in all editor dialogs.\"\n            dialogCancel=\"Cancel\"\n\n            i18n-dialogInsert=\"kendo.editor.dialogInsert|The label of the **Insert** button in all editor dialogs.\"\n            dialogInsert=\"Insert\"\n\n            i18n-dialogUpdate=\"kendo.editor.dialogUpdate|The label of the **Update** button in all editor dialogs.\"\n            dialogUpdate=\"Update\"\n\n            i18n-fileText=\"kendo.editor.fileText|The caption for the file text in the insertFile dialog.\"\n            fileText=\"Text\"\n\n            i18n-fileTitle=\"kendo.editor.fileTitle|The caption for the file Title in the insertFile dialog.\"\n            fileTitle=\"Title\"\n\n            i18n-fileWebAddress=\"kendo.editor.fileWebAddress|The caption for the file URL in the insertFile dialog.\"\n            fileWebAddress=\"Web address\"\n\n            i18n-fontFamily=\"kendo.editor.fontFamily|The title of the tool that changes the text font.\"\n            fontFamily=\"Select font family\"\n\n            i18n-fontSize=\"kendo.editor.fontSize|The title of the tool that changes the text size.\"\n            fontSize=\"Select font size\"\n\n            i18n-foreColor=\"kendo.editor.foreColor|The title of the tool that changes the text color.\"\n            foreColor=\"Color\"\n\n            i18n-format=\"kendo.editor.format|The title of the tool that lets users choose block formats.\"\n            format=\"Format\"\n\n            i18n-imageAltText=\"kendo.editor.imageAltText|The caption for the image alternate text in the insertImage dialog.\"\n            imageAltText=\"Alternate text\"\n\n            i18n-imageHeight=\"kendo.editor.imageHeight|The caption for the image height in the insertImage dialog.\"\n            imageHeight=\"Height (px)\"\n\n            i18n-imageWebAddress=\"kendo.editor.imageWebAddress|The caption for the image URL in the insertImage dialog.\"\n            imageWebAddress=\"Web address\"\n\n            i18n-imageWidth=\"kendo.editor.imageWidth|The caption for the image width in the insertImage dialog.\"\n            imageWidth=\"Width (px)\"\n\n            i18n-indent=\"kendo.editor.indent|The title of the tool that indents the content.\"\n            indent=\"Indent\"\n\n            i18n-insertFile=\"kendo.editor.insertFile|The title of the tool that inserts links to files.\"\n            insertFile=\"Insert file\"\n\n            i18n-insertImage=\"kendo.editor.insertImage|The title of the tool that inserts images.\"\n            insertImage=\"Insert image\"\n\n            i18n-insertOrderedList=\"kendo.editor.insertOrderedList|The title of the tool that inserts an ordered list.\"\n            insertOrderedList=\"Insert ordered list\"\n\n            i18n-insertUnorderedList=\"kendo.editor.insertUnorderedList|The title of the tool that inserts an unordered list.\"\n            insertUnorderedList=\"Insert unordered list\"\n\n            i18n-italic=\"kendo.editor.italic|The title of the tool that makes text italicized.\"\n            italic=\"Italic\"\n\n            i18n-linkOpenInNewWindow=\"kendo.editor.linkOpenInNewWindow|The caption for the checkbox for opening the link in a new window in the createLink dialog.\"\n            linkOpenInNewWindow=\"Open link in new window\"\n\n            i18n-linkText=\"kendo.editor.linkText|The caption for the link text in the createLink dialog.\"\n            linkText=\"Text\"\n\n            i18n-linkTitle=\"kendo.editor.linkTitle|The caption for the link title in the createLink dialog.\"\n            linkTitle=\"Title\"\n\n            i18n-linkWebAddress=\"kendo.editor.linkWebAddress|The caption for the URL in the createLink dialog.\"\n            linkWebAddress=\"Web address\"\n\n            i18n-outdent=\"kendo.editor.outdent|The title of the tool that outdents the content.\"\n            outdent=\"Outdent\"\n\n            i18n-redo=\"kendo.editor.redo|The title of the tool that undos the last action.\"\n            redo=\"Redo\"\n\n            i18n-strikethrough=\"kendo.editor.strikethrough|The title of the tool that strikes through text.\"\n            strikethrough=\"Strikethrough\"\n\n            i18n-subscript=\"kendo.editor.subscript|The title of the tool that makes text subscript.\"\n            subscript=\"Subscript\"\n\n            i18n-superscript=\"kendo.editor.superscript|The title of the tool that makes text superscript.\"\n            superscript=\"Superscript\"\n\n            i18n-underline=\"kendo.editor.underline|The title of the tool that underlines text.\"\n            underline=\"Underline\"\n\n            i18n-unlink=\"kendo.editor.unlink|The title of the tool that removes hyperlinks.\"\n            unlink=\"Remove Link\"\n\n            i18n-undo=\"kendo.editor.undo|The title of the tool that undos the last action.\"\n            undo=\"Undo\"\n\n            i18n-viewSource=\"kendo.editor.viewSource|The title of the tool that shows the editor value as HTML.\"\n            viewSource=\"View source\"\n\n            i18n-insertTable=\"kendo.editor.insertTable|The title of the tool that inserts table.\"\n            insertTable=\"Insert Table\"\n\n            i18n-addColumnBefore=\"kendo.editor.addColumnBefore|The title of the tool that adds new column before currently selected column.\"\n            addColumnBefore=\"Add column before\"\n\n            i18n-addColumnAfter=\"kendo.editor.addColumnAfter|The title of the tool that adds new column after currently selected column.\"\n            addColumnAfter=\"Add column after\"\n\n            i18n-addRowBefore=\"kendo.editor.addRowBefore|The title of the tool that adds new row before currently selected row.\"\n            addRowBefore=\"Add row before\"\n\n            i18n-addRowAfter=\"kendo.editor.addRowAfter|The title of the tool that adds new row after currently selected row.\"\n            addRowAfter=\"Add row after\"\n\n            i18n-deleteColumn=\"kendo.editor.deleteColumn|The title of the tool that deletes a table column.\"\n            deleteColumn=\"Delete column\"\n\n            i18n-deleteRow=\"kendo.editor.deleteRow|The title of the tool that deletes a table row.\"\n            deleteRow=\"Delete row\"\n\n            i18n-deleteTable=\"kendo.editor.deleteTable|The title of the tool that deletes a table.\"\n            deleteTable=\"Delete table\"\n        >\n        </ng-container>\n\n        <ng-content select=\"kendo-toolbar\"></ng-content>\n        <kendo-toolbar [overflow]=\"true\" *ngIf=\"!userToolBarElement\" #defaultToolbar>\n            <kendo-toolbar-buttongroup>\n                <kendo-toolbar-button kendoEditorBoldButton></kendo-toolbar-button>\n                <kendo-toolbar-button kendoEditorItalicButton></kendo-toolbar-button>\n                <kendo-toolbar-button kendoEditorUnderlineButton></kendo-toolbar-button>\n            </kendo-toolbar-buttongroup>\n            <kendo-toolbar-dropdownlist kendoEditorFormat></kendo-toolbar-dropdownlist>\n            <kendo-toolbar-buttongroup>\n                <kendo-toolbar-button kendoEditorAlignLeftButton></kendo-toolbar-button>\n                <kendo-toolbar-button kendoEditorAlignCenterButton></kendo-toolbar-button>\n                <kendo-toolbar-button kendoEditorAlignRightButton></kendo-toolbar-button>\n                <kendo-toolbar-button kendoEditorAlignJustifyButton></kendo-toolbar-button>\n            </kendo-toolbar-buttongroup>\n            <kendo-toolbar-buttongroup>\n                <kendo-toolbar-button kendoEditorInsertUnorderedListButton></kendo-toolbar-button>\n                <kendo-toolbar-button kendoEditorInsertOrderedListButton></kendo-toolbar-button>\n                <kendo-toolbar-button kendoEditorIndentButton></kendo-toolbar-button>\n                <kendo-toolbar-button kendoEditorOutdentButton></kendo-toolbar-button>\n            </kendo-toolbar-buttongroup>\n            <kendo-toolbar-buttongroup>\n                <kendo-toolbar-button kendoEditorCreateLinkButton></kendo-toolbar-button>\n                <kendo-toolbar-button kendoEditorUnlinkButton></kendo-toolbar-button>\n            </kendo-toolbar-buttongroup>\n            <kendo-toolbar-button kendoEditorInsertImageButton></kendo-toolbar-button>\n        </kendo-toolbar>\n\n        <div *ngIf=\"!iframe\" #content [attr.dir]=\"direction\" class=\"k-content\"></div>\n\n        <iframe *ngIf=\"iframe\" #content frameborder=\"0\" class=\"k-content\" (load)=\"iframeOnLoad()\"></iframe>\n\n        <ng-container #dialogsContainer></ng-container>\n    ",
                    /* tslint:enable:max-line-length */
                    styles: ["\n        >>> .k-content > .ProseMirror {\n            height: 100%;\n            width: 100%;\n            box-sizing: border-box;\n            outline: none;\n            overflow: auto;\n        }\n    "]
                },] },
    ];
    /** @nocollapse */
    EditorComponent.ctorParameters = function () { return [
        { type: DialogService },
        { type: LocalizationService },
        { type: ChangeDetectorRef },
        { type: NgZone }
    ]; };
    EditorComponent.propDecorators = {
        value: [{ type: Input }],
        iframe: [{ type: Input }],
        updateInterval: [{ type: Input }],
        valueChange: [{ type: Output }],
        hostClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-editor',] }],
        isIE: [{ type: HostBinding, args: ['class.k-ie',] }],
        dir: [{ type: HostBinding, args: ['attr.dir',] }],
        userToolBarComponent: [{ type: ContentChild, args: [ToolBarComponent,] }],
        userToolBarElement: [{ type: ContentChild, args: [ToolBarComponent, { read: ElementRef },] }],
        dialogContainer: [{ type: ViewChild, args: ['dialogsContainer', { read: ViewContainerRef },] }],
        container: [{ type: ViewChild, args: ['content', { read: ViewContainerRef },] }],
        defaultToolbar: [{ type: ViewChild, args: ['defaultToolbar', { read: ElementRef },] }],
        defaultToolbarComponent: [{ type: ViewChild, args: ['defaultToolbar', { read: ToolBarComponent },] }]
    };
    return EditorComponent;
}());

/**
 * @hidden
 */
var FormatDialogComponent = /** @class */ (function (_super) {
    __extends(FormatDialogComponent, _super);
    function FormatDialogComponent(dialog, localization) {
        var _this = _super.call(this, dialog) || this;
        _this.dialog = dialog;
        _this.localization = localization;
        _this.data = [];
        return _this;
    }
    FormatDialogComponent.prototype.onCancelAction = function () {
        this.dialog.close();
    };
    FormatDialogComponent.prototype.onConfirmAction = function () {
        if (this.value) {
            this.editor.exec('format', { tag: this.value });
        }
        this.dialog.close();
    };
    FormatDialogComponent.prototype.setData = function (args) {
        this.editor = args.editor;
        this.data = args.data;
        this.defaultItem = args.defaultItem;
        this.value = args.value;
        this.itemDisabled = args.itemDisabled;
    };
    FormatDialogComponent.prototype.textFor = function (key) {
        return this.localization.get(key);
    };
    FormatDialogComponent.decorators = [
        { type: Component, args: [{
                    template: "\n        <kendo-dialog-titlebar>\n            {{ textFor('format') }}\n        </kendo-dialog-titlebar>\n        <div class=\"k-editor-dialog\">\n            <div class=\"k-editor-dialog k-popup-edit-form k-window-content k-content\">\n                <div class=\"k-edit-form-container k-window-content\" style=\"text-align: center;\">\n                    <kendo-editor-format-dropdownlist\n                        #formatDropDownList\n                        [defaultItem]=\"defaultItem\"\n                        [data]=\"data\"\n                        [(value)]=\"value\"\n                        [itemDisabled]=\"itemDisabled\"\n                    >\n                    </kendo-editor-format-dropdownlist>\n                </div>\n            </div>\n        </div>\n        <kendo-dialog-actions>\n            <button kendoButton (click)=\"onCancelAction()\">{{ textFor('dialogCancel') }}</button>\n            <button kendoButton\n                    (click)=\"onConfirmAction()\" [primary]=\"true\">{{ textFor('dialogApply') }}</button>\n        </kendo-dialog-actions>\n    "
                },] },
    ];
    /** @nocollapse */
    FormatDialogComponent.ctorParameters = function () { return [
        { type: DialogRef },
        { type: EditorLocalizationService }
    ]; };
    FormatDialogComponent.propDecorators = {
        editor: [{ type: Input }]
    };
    return FormatDialogComponent;
}(DialogContentBase));

/**
 * @hidden
 */
var ColorPickerDialogComponent = /** @class */ (function (_super) {
    __extends(ColorPickerDialogComponent, _super);
    function ColorPickerDialogComponent(dialog, localization) {
        var _this = _super.call(this, dialog) || this;
        _this.dialog = dialog;
        _this.localization = localization;
        return _this;
    }
    ColorPickerDialogComponent.prototype.handleActiveColorClick = function (event) {
        event.preventOpen();
        this.value = event.color;
    };
    ColorPickerDialogComponent.prototype.onCancelAction = function () {
        this.dialog.close();
    };
    ColorPickerDialogComponent.prototype.onConfirmAction = function () {
        if (this.value) {
            this.editor.exec(this.editorCommand, this.value);
        }
        this.dialog.close();
    };
    ColorPickerDialogComponent.prototype.setData = function (args) {
        this.editor = args.editor;
        this.value = args.value;
        this.editorCommand = args.editorCommand;
        this.paletteSettings = args.paletteSettings;
        this.icon = args.icon;
    };
    ColorPickerDialogComponent.prototype.textFor = function (key) {
        return this.localization.get(key);
    };
    ColorPickerDialogComponent.decorators = [
        { type: Component, args: [{
                    template: "\n        <kendo-dialog-titlebar>\n            {{ textFor('format') }}\n        </kendo-dialog-titlebar>\n        <div class=\"k-editor-dialog\">\n            <div class=\"k-editor-dialog k-popup-edit-form k-window-content k-content\">\n                <div class=\"k-edit-form-container k-window-content\" style=\"text-align: center;\">\n                    <kendo-colorpicker\n                        #colorpicker\n                        [view]=\"'palette'\"\n                        [format]=\"'hex'\"\n                        [attr.title]=\"title\"\n                        [icon]=\"icon\"\n                        [(value)]=\"value\"\n                        [paletteSettings]=\"paletteSettings\"\n                        (activeColorClick)=\"handleActiveColorClick($event)\"\n                    >\n                    </kendo-colorpicker>\n                </div>\n            </div>\n        </div>\n        <kendo-dialog-actions>\n            <button kendoButton (click)=\"onCancelAction()\">{{ textFor('dialogCancel') }}</button>\n            <button kendoButton\n                    (click)=\"onConfirmAction()\" [primary]=\"true\">{{ textFor('dialogApply') }}</button>\n        </kendo-dialog-actions>\n    "
                },] },
    ];
    /** @nocollapse */
    ColorPickerDialogComponent.ctorParameters = function () { return [
        { type: DialogRef },
        { type: EditorLocalizationService }
    ]; };
    ColorPickerDialogComponent.propDecorators = {
        editor: [{ type: Input }]
    };
    return ColorPickerDialogComponent;
}(DialogContentBase));

/**
 * @hidden
 */
var FontFamilyDialogComponent = /** @class */ (function (_super) {
    __extends(FontFamilyDialogComponent, _super);
    function FontFamilyDialogComponent(dialog, localization) {
        var _this = _super.call(this, dialog) || this;
        _this.dialog = dialog;
        _this.localization = localization;
        _this.data = [];
        return _this;
    }
    FontFamilyDialogComponent.prototype.onCancelAction = function () {
        this.dialog.close();
    };
    FontFamilyDialogComponent.prototype.onConfirmAction = function () {
        if (this.value) {
            this.editor.exec('fontFamily', this.value);
        }
        this.dialog.close();
    };
    FontFamilyDialogComponent.prototype.setData = function (args) {
        this.editor = args.editor;
        this.data = args.data;
        this.defaultItem = args.defaultItem;
        this.value = args.value;
        this.itemDisabled = args.itemDisabled;
    };
    FontFamilyDialogComponent.prototype.textFor = function (key) {
        return this.localization.get(key);
    };
    FontFamilyDialogComponent.decorators = [
        { type: Component, args: [{
                    template: "\n        <kendo-dialog-titlebar>\n            {{ textFor('fontFamily') }}\n        </kendo-dialog-titlebar>\n        <div class=\"k-editor-dialog\">\n            <div class=\"k-editor-dialog k-popup-edit-form k-window-content k-content\">\n                <div class=\"k-edit-form-container k-window-content\" style=\"text-align: center;\">\n                    <kendo-editor-fontfamily-dropdownlist\n                        #fontFamilyDropDownList\n                        [defaultItem]=\"defaultItem\"\n                        [data]=\"data\"\n                        [(value)]=\"value\"\n                        [itemDisabled]=\"itemDisabled\"\n                    >\n                    </kendo-editor-fontfamily-dropdownlist>\n                </div>\n            </div>\n        </div>\n        <kendo-dialog-actions>\n            <button kendoButton (click)=\"onCancelAction()\">{{ textFor('dialogCancel') }}</button>\n            <button kendoButton\n                    (click)=\"onConfirmAction()\" [primary]=\"true\">{{ textFor('dialogApply') }}</button>\n        </kendo-dialog-actions>\n    "
                },] },
    ];
    /** @nocollapse */
    FontFamilyDialogComponent.ctorParameters = function () { return [
        { type: DialogRef },
        { type: EditorLocalizationService }
    ]; };
    FontFamilyDialogComponent.propDecorators = {
        editor: [{ type: Input }]
    };
    return FontFamilyDialogComponent;
}(DialogContentBase));

/**
 * @hidden
 */
var InsertTableDialogComponent = /** @class */ (function (_super) {
    __extends(InsertTableDialogComponent, _super);
    function InsertTableDialogComponent(dialog, localization) {
        var _this = _super.call(this, dialog) || this;
        _this.dialog = dialog;
        _this.localization = localization;
        return _this;
    }
    InsertTableDialogComponent.prototype.onCancelAction = function () {
        this.dialog.close();
    };
    InsertTableDialogComponent.prototype.onCellClick = function (args) {
        this.dialog.close();
        this.editor.exec("insertTable", args);
    };
    InsertTableDialogComponent.prototype.setData = function (args) {
        this.editor = args.editor;
    };
    InsertTableDialogComponent.prototype.textFor = function (key) {
        return this.localization.get(key);
    };
    InsertTableDialogComponent.decorators = [
        { type: Component, args: [{
                    template: "\n        <kendo-dialog-titlebar>\n            {{ textFor('insertTable') }}\n        </kendo-dialog-titlebar>\n        <div class=\"k-editor-dialog\">\n            <div class=\"k-editor-dialog k-popup-edit-form k-window-content k-content\">\n                <div class=\"k-ct-popup k-window-content\" style=\"text-align: center;\">\n                    <kendo-popup-table-grid (cellClick)=\"onCellClick($event)\"></kendo-popup-table-grid>\n                </div>\n            </div>\n        </div>\n        <kendo-dialog-actions>\n            <button kendoButton (click)=\"onCancelAction()\">{{ textFor('dialogCancel') }}</button>\n        </kendo-dialog-actions>\n    "
                },] },
    ];
    /** @nocollapse */
    InsertTableDialogComponent.ctorParameters = function () { return [
        { type: DialogRef },
        { type: EditorLocalizationService }
    ]; };
    InsertTableDialogComponent.propDecorators = {
        editor: [{ type: Input }]
    };
    return InsertTableDialogComponent;
}(DialogContentBase));

/**
 * @hidden
 */
var FormatDropDownListComponent = /** @class */ (function () {
    function FormatDropDownListComponent() {
        this.valueChange = new EventEmitter();
    }
    FormatDropDownListComponent.prototype.onValueChange = function (tag) {
        this.valueChange.emit(tag);
    };
    FormatDropDownListComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:no-forward-ref
                    selector: 'kendo-editor-format-dropdownlist',
                    template: "\n        <kendo-dropdownlist\n            #element\n            [defaultItem]=\"defaultItem\"\n            [textField]=\"'text'\"\n            [valueField]=\"'tag'\"\n            [data]=\"data\"\n            [(value)]=\"value\"\n            [valuePrimitive]=\"true\"\n            [itemDisabled]=\"itemDisabled\"\n            [attr.title]=\"title\"\n            (valueChange)=\"onValueChange($event)\"\n        >\n            <ng-template kendoDropDownListItemTemplate let-dataItem>\n                <ng-container [ngSwitch]=\"dataItem.tag\">\n                    <span *ngSwitchCase=\"'h1'\" style=\"display: block; font-size: 2em; margin-left: 0; font-weight: bold;\">\n                        {{ dataItem.text }}\n                    </span>\n\n                    <span *ngSwitchCase=\"'h2'\" style=\"display: block; font-size: 1.5em; margin-left: 0; font-weight: bold;\">\n                        {{ dataItem.text }}\n                    </span>\n\n                    <span *ngSwitchCase=\"'h3'\" style=\"display: block; font-size: 1.17em; margin-left: 0; font-weight: bold;\">\n                        {{ dataItem.text }}\n                    </span>\n\n                    <span *ngSwitchCase=\"'h4'\" style=\"display: block; font-size: 1em; margin-left: 0; font-weight: bold;\">\n                        {{ dataItem.text }}\n                    </span>\n\n                    <span *ngSwitchCase=\"'h5'\" style=\"display: block; font-size: .83em; margin-left: 0; font-weight: bold;\">\n                        {{ dataItem.text }}\n                    </span>\n\n                    <span *ngSwitchCase=\"'h6'\" style=\"display: block; font-size: .67em; margin-left: 0; font-weight: bold;\">\n                        {{ dataItem.text }}\n                    </span>\n\n                    <span *ngSwitchCase=\"'p'\" style=\"display: block; margin-left: 0;\">\n                        {{ dataItem.text }}\n                    </span>\n\n                    <span *ngSwitchCase=\"'blockquote'\" style=\"display: block; margin-left: 0;\">\n                        {{ dataItem.text }}\n                    </span>\n\n                    <span *ngSwitchDefault>{{ dataItem.text }}</span>\n                </ng-container>\n            </ng-template>\n        </kendo-dropdownlist>\n    "
                },] },
    ];
    FormatDropDownListComponent.propDecorators = {
        data: [{ type: Input }],
        value: [{ type: Input }],
        defaultItem: [{ type: Input }],
        itemDisabled: [{ type: Input }],
        title: [{ type: Input }],
        valueChange: [{ type: Output }],
        element: [{ type: ViewChild, args: ['element',] }]
    };
    return FormatDropDownListComponent;
}());

/**
 * A component which configures an existing `DropDownListComponent` as an Editor tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The component associates a `kendo-dropdownlist` with an Editor command that changes the format of a content block and
 * automatically defines the options of the drop-down list and sets its values.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-dropdownlist kendoEditorFormat></kendo-toolbar-dropdownlist>
 * ```
 */
var EditorFormatComponent = /** @class */ (function (_super) {
    __extends(EditorFormatComponent, _super);
    function EditorFormatComponent(editor, dialogService, localization) {
        var _this = _super.call(this) || this;
        _this.editor = editor;
        _this.dialogService = dialogService;
        _this.localization = localization;
        /**
         * Fires when the user updates the value of the drop-down list.
         */
        _this.valueChange = new EventEmitter();
        _this._data = [
            { text: 'Paragraph', tag: 'p' },
            { text: 'Quotation', tag: 'blockquote' },
            { text: 'Heading 1', tag: 'h1' },
            { text: 'Heading 2', tag: 'h2' },
            { text: 'Heading 3', tag: 'h3' },
            { text: 'Heading 4', tag: 'h4' },
            { text: 'Heading 5', tag: 'h5' },
            { text: 'Heading 6', tag: 'h6' }
        ];
        return _this;
    }
    Object.defineProperty(EditorFormatComponent.prototype, "data", {
        get: function () {
            return this._data;
        },
        /**
         * Overrides the default format items list.
         */
        set: function (formatItems) {
            this._data = formatItems || this._data;
        },
        enumerable: true,
        configurable: true
    });
    EditorFormatComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.itemDisabled = function (itemArgs) {
            return itemArgs.dataItem.tag === null;
        };
        setTimeout(function () { return (_this.defaultItem = { text: _this.title, tag: null }); });
        this.subs = this.editor.stateChange.subscribe(function (_a) {
            var format = _a.format;
            var index = _this.data.findIndex(function (item) { return item.tag === format.tag; });
            _this.value = index !== -1 ? format.tag : null;
        });
    };
    /**
     * @hidden
     */
    EditorFormatComponent.prototype.onValueChange = function (ev) {
        if (isPresent(ev)) {
            this.editor.exec('format', { tag: ev });
            this.editor.focus();
            this.valueChange.emit(this.data.find(function (d) { return d.tag === ev; }));
        }
    };
    EditorFormatComponent.prototype.ngOnDestroy = function () {
        this.subs.unsubscribe();
    };
    Object.defineProperty(EditorFormatComponent.prototype, "outerWidth", {
        get: function () {
            var element = this.formatDropDownList.element;
            if (element) {
                return outerWidth(element.nativeElement);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorFormatComponent.prototype, "title", {
        get: function () {
            return this.localization.get('format');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    EditorFormatComponent.prototype.openDialog = function () {
        var dialogSettings = {
            appendTo: this.editor.dialogContainer,
            content: FormatDialogComponent
        };
        this.editor.toolbar.toggle(false);
        var dialogContent = this.dialogService.open(dialogSettings).content.instance;
        dialogContent.setData({
            editor: this.editor,
            data: this.data,
            defaultItem: this.defaultItem,
            value: this.value,
            itemDisabled: this.itemDisabled
        });
    };
    EditorFormatComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:no-forward-ref
                    providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(function () { return EditorFormatComponent; }) }],
                    selector: 'kendo-toolbar-dropdownlist[kendoEditorFormat]',
                    template: "\n        <ng-template #toolbarTemplate>\n            <kendo-editor-format-dropdownlist\n                #formatDropDownList\n                [defaultItem]=\"defaultItem\"\n                [data]=\"data\"\n                [(value)]=\"value\"\n                [itemDisabled]=\"itemDisabled\"\n                [title]=\"title\"\n                (valueChange)=\"onValueChange($event)\"\n            >\n            </kendo-editor-format-dropdownlist>\n        </ng-template>\n        <ng-template #popupTemplate>\n            <button\n                tabindex=\"-1\"\n                type=\"button\"\n                kendoButton\n                class=\"k-overflow-button\"\n                [icon]=\"'apply-format'\"\n                [attr.title]=\"title\"\n                (click)=\"openDialog()\"\n            >\n                {{ title }}\n            </button>\n        </ng-template>\n    "
                },] },
    ];
    /** @nocollapse */
    EditorFormatComponent.ctorParameters = function () { return [
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: DialogService },
        { type: EditorLocalizationService }
    ]; };
    EditorFormatComponent.propDecorators = {
        data: [{ type: Input }],
        valueChange: [{ type: Output }],
        toolbarTemplate: [{ type: ViewChild, args: ['toolbarTemplate',] }],
        popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],
        formatDropDownList: [{ type: ViewChild, args: ['formatDropDownList',] }]
    };
    return EditorFormatComponent;
}(ToolBarToolComponent));

/**
 * @hidden
 */
var FontSizeDialogComponent = /** @class */ (function (_super) {
    __extends(FontSizeDialogComponent, _super);
    function FontSizeDialogComponent(dialog, localization) {
        var _this = _super.call(this, dialog) || this;
        _this.dialog = dialog;
        _this.localization = localization;
        _this.data = [];
        return _this;
    }
    FontSizeDialogComponent.prototype.onCancelAction = function () {
        this.dialog.close();
    };
    FontSizeDialogComponent.prototype.onConfirmAction = function () {
        if (this.value) {
            this.editor.exec('fontSize', this.value);
        }
        this.dialog.close();
    };
    FontSizeDialogComponent.prototype.setData = function (args) {
        this.editor = args.editor;
        this.data = args.data;
        this.defaultItem = args.defaultItem;
        this.value = args.value;
        this.itemDisabled = args.itemDisabled;
    };
    FontSizeDialogComponent.prototype.textFor = function (key) {
        return this.localization.get(key);
    };
    FontSizeDialogComponent.decorators = [
        { type: Component, args: [{
                    template: "\n        <kendo-dialog-titlebar>\n            {{ textFor('fontSize') }}\n        </kendo-dialog-titlebar>\n        <div class=\"k-editor-dialog\">\n            <div class=\"k-editor-dialog k-popup-edit-form k-window-content k-content\">\n                <div class=\"k-edit-form-container k-window-content\" style=\"text-align: center;\">\n                    <kendo-editor-fontsize-dropdownlist\n                        #fontSizeDropDownList\n                        [defaultItem]=\"defaultItem\"\n                        [data]=\"data\"\n                        [(value)]=\"value\"\n                        [itemDisabled]=\"itemDisabled\"\n                    >\n                    </kendo-editor-fontsize-dropdownlist>\n                </div>\n            </div>\n        </div>\n        <kendo-dialog-actions>\n            <button kendoButton (click)=\"onCancelAction()\">{{ textFor('dialogCancel') }}</button>\n            <button kendoButton\n                    (click)=\"onConfirmAction()\" [primary]=\"true\">{{ textFor('dialogApply') }}</button>\n        </kendo-dialog-actions>\n    "
                },] },
    ];
    /** @nocollapse */
    FontSizeDialogComponent.ctorParameters = function () { return [
        { type: DialogRef },
        { type: EditorLocalizationService }
    ]; };
    FontSizeDialogComponent.propDecorators = {
        editor: [{ type: Input }]
    };
    return FontSizeDialogComponent;
}(DialogContentBase));

/**
 * A component which configures an existing `DropDownListComponent` as an Editor tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The component associates a `kendo-dropdownlist` with an Editor command that changes the font size of a content block and
 * automatically defines the options of the drop-down list and sets its values.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-dropdownlist kendoEditorFontSize></kendo-toolbar-dropdownlist>
 * ```
 */
var EditorFontSizeComponent = /** @class */ (function (_super) {
    __extends(EditorFontSizeComponent, _super);
    function EditorFontSizeComponent(editor, dialogService, localization) {
        var _this = _super.call(this) || this;
        _this.editor = editor;
        _this.dialogService = dialogService;
        _this.localization = localization;
        /**
         * Fires when the user updates the value of the drop-down list.
         */
        _this.valueChange = new EventEmitter();
        _this._data = [
            { text: '8px', size: 8 },
            { text: '10px', size: 10 },
            { text: '12px', size: 12 },
            { text: '14px', size: 14 },
            { text: '18px', size: 18 },
            { text: '24px', size: 24 },
            { text: '36px', size: 36 }
        ];
        return _this;
    }
    Object.defineProperty(EditorFontSizeComponent.prototype, "data", {
        get: function () {
            return this._data;
        },
        /**
         * Overrides the default font size list.
         */
        set: function (sizes) {
            this._data = sizes || this._data;
        },
        enumerable: true,
        configurable: true
    });
    EditorFontSizeComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.itemDisabled = function (itemArgs) {
            return itemArgs.dataItem.size === null;
        };
        setTimeout(function () { return (_this.defaultItem = { text: _this.title, size: null }); });
        this.subs = this.editor.stateChange.subscribe(function (_a) {
            var style = _a.style;
            // remove units(px, em, rem...)
            // string#match returns array
            _this.value = (getUniqueStyleValues(style, 'font-size').match(/\d+/g) || [null])[0];
        });
    };
    /**
     * @hidden
     */
    EditorFontSizeComponent.prototype.onValueChange = function (ev) {
        if (isPresent(ev)) {
            this.editor.exec('fontSize', ev);
            this.editor.focus();
            this.valueChange.emit(this.data.find(function (d) { return d.size === parseInt(ev, 10); }));
        }
    };
    EditorFontSizeComponent.prototype.ngOnDestroy = function () {
        this.subs.unsubscribe();
    };
    Object.defineProperty(EditorFontSizeComponent.prototype, "outerWidth", {
        get: function () {
            if (this.element) {
                return outerWidth(this.element.nativeElement);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorFontSizeComponent.prototype, "title", {
        get: function () {
            return this.localization.get('fontSize');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    EditorFontSizeComponent.prototype.openDialog = function () {
        var dialogSettings = {
            appendTo: this.editor.dialogContainer,
            content: FontSizeDialogComponent
        };
        this.editor.toolbar.toggle(false);
        var dialogContent = this.dialogService.open(dialogSettings).content.instance;
        dialogContent.setData({
            editor: this.editor,
            data: this.data,
            defaultItem: this.defaultItem,
            value: this.value,
            itemDisabled: this.itemDisabled
        });
    };
    EditorFontSizeComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:no-forward-ref
                    providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(function () { return EditorFontSizeComponent; }) }],
                    selector: 'kendo-toolbar-dropdownlist[kendoEditorFontSize]',
                    template: "\n        <ng-template #toolbarTemplate>\n            <kendo-editor-fontsize-dropdownlist\n                #element\n                [defaultItem]=\"defaultItem\"\n                [data]=\"data\"\n                [(value)]=\"value\"\n                [itemDisabled]=\"itemDisabled\"\n                [title]=\"title\"\n                (valueChange)=\"onValueChange($event)\"\n            >\n            </kendo-editor-fontsize-dropdownlist>\n        </ng-template>\n        <ng-template #popupTemplate>\n            <button\n                tabindex=\"-1\"\n                type=\"button\"\n                kendoButton\n                class=\"k-overflow-button\"\n                [icon]=\"'font-size'\"\n                [attr.title]=\"title\"\n                (click)=\"openDialog()\"\n            >\n                {{ title }}\n            </button>\n        </ng-template>\n    "
                },] },
    ];
    /** @nocollapse */
    EditorFontSizeComponent.ctorParameters = function () { return [
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: DialogService },
        { type: EditorLocalizationService }
    ]; };
    EditorFontSizeComponent.propDecorators = {
        data: [{ type: Input }],
        valueChange: [{ type: Output }],
        toolbarTemplate: [{ type: ViewChild, args: ['toolbarTemplate',] }],
        popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],
        element: [{ type: ViewChild, args: ['element',] }]
    };
    return EditorFontSizeComponent;
}(ToolBarToolComponent));

/**
 * A component which configures an existing `DropDownListComponent` as an Editor tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The component associates a `kendo-toolbar-dropdownlist` with an Editor command that changes the font family of a content block and
 * automatically defines the options of the drop-down list and sets its values.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-dropdownlist kendoEditorFontFamily></kendo-toolbar-dropdownlist>
 * ```
 */
var EditorFontFamilyComponent = /** @class */ (function (_super) {
    __extends(EditorFontFamilyComponent, _super);
    function EditorFontFamilyComponent(editor, dialogService, localization) {
        var _this = _super.call(this) || this;
        _this.editor = editor;
        _this.dialogService = dialogService;
        _this.localization = localization;
        /**
         * Fires when the user updates the value of the drop-down list.
         */
        _this.valueChange = new EventEmitter();
        _this._data = [
            { text: 'Arial', fontName: 'Arial,"Helvetica Neue",Helvetica,sans-serif' },
            { text: 'Courier New', fontName: '"Courier New",Courier,"Lucida Sans Typewriter","Lucida Typewriter",monospace' },
            { text: 'Georgia', fontName: 'Georgia,Times,"Times New Roman",serif' },
            {
                fontName: 
                // tslint:disable-next-line:max-line-length
                'Impact,Haettenschweiler,"Franklin Gothic Bold",Charcoal,"Helvetica Inserat","Bitstream Vera Sans Bold","Arial Black","sans serif"',
                text: 'Impact'
            },
            { text: 'Lucida Console', fontName: '"Lucida Console","Lucida Sans Typewriter",monaco,"Bitstream Vera Sans Mono",monospace' },
            { text: 'Tahoma', fontName: 'Tahoma,Verdana,Segoe,sans-serif' },
            { text: 'Times New Roman', fontName: 'TimesNewRoman,"Times New Roman",Times,Baskerville,Georgia,serif' },
            { text: 'Trebuchet MS', fontName: '"Trebuchet MS","Lucida Grande","Lucida Sans Unicode","Lucida Sans",Tahoma,sans-serif' },
            { text: 'Verdana', fontName: 'Verdana,Geneva,sans-serif' }
        ];
        return _this;
    }
    Object.defineProperty(EditorFontFamilyComponent.prototype, "data", {
        get: function () {
            return this._data;
        },
        /**
         * Overrides the default font list.
         */
        set: function (fonts) {
            this._data = fonts || this._data;
        },
        enumerable: true,
        configurable: true
    });
    EditorFontFamilyComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.itemDisabled = function (itemArgs) {
            return itemArgs.dataItem.fontName === null;
        };
        setTimeout(function () { return (_this.defaultItem = { text: _this.title, fontName: null }); });
        this.subs = this.editor.stateChange.subscribe(function (_a) {
            var style = _a.style;
            _this.value = getUniqueStyleValues(style, 'font-family') || null;
        });
    };
    /**
     * @hidden
     */
    EditorFontFamilyComponent.prototype.onValueChange = function (ev) {
        if (isPresent(ev)) {
            this.editor.exec('fontFamily', ev);
            this.editor.focus();
            this.valueChange.emit(this.data.find(function (f) { return f.fontName === ev; }));
        }
    };
    EditorFontFamilyComponent.prototype.ngOnDestroy = function () {
        this.subs.unsubscribe();
    };
    Object.defineProperty(EditorFontFamilyComponent.prototype, "outerWidth", {
        get: function () {
            if (this.element) {
                return outerWidth(this.element.nativeElement);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorFontFamilyComponent.prototype, "title", {
        get: function () {
            return this.localization.get('fontFamily');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    EditorFontFamilyComponent.prototype.openDialog = function () {
        var dialogSettings = {
            appendTo: this.editor.dialogContainer,
            content: FontFamilyDialogComponent
        };
        this.editor.toolbar.toggle(false);
        var dialogContent = this.dialogService.open(dialogSettings).content.instance;
        dialogContent.setData({
            editor: this.editor,
            data: this.data,
            defaultItem: this.defaultItem,
            value: this.value,
            itemDisabled: this.itemDisabled
        });
    };
    EditorFontFamilyComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:no-forward-ref
                    providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(function () { return EditorFontFamilyComponent; }) }],
                    selector: 'kendo-toolbar-dropdownlist[kendoEditorFontFamily]',
                    template: "\n        <ng-template #toolbarTemplate>\n            <kendo-editor-fontfamily-dropdownlist\n                #element\n                [defaultItem]=\"defaultItem\"\n                [data]=\"data\"\n                [(value)]=\"value\"\n                [itemDisabled]=\"itemDisabled\"\n                [title]=\"title\"\n                (valueChange)=\"onValueChange($event)\"\n            >\n            </kendo-editor-fontfamily-dropdownlist>\n        </ng-template>\n        <ng-template #popupTemplate>\n            <button\n                tabindex=\"-1\"\n                type=\"button\"\n                kendoButton\n                class=\"k-overflow-button\"\n                [icon]=\"'font-family'\"\n                [attr.title]=\"title\"\n                (click)=\"openDialog()\"\n            >\n                {{ title }}\n            </button>\n        </ng-template>\n    "
                },] },
    ];
    /** @nocollapse */
    EditorFontFamilyComponent.ctorParameters = function () { return [
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: DialogService },
        { type: EditorLocalizationService }
    ]; };
    EditorFontFamilyComponent.propDecorators = {
        data: [{ type: Input }],
        valueChange: [{ type: Output }],
        toolbarTemplate: [{ type: ViewChild, args: ['toolbarTemplate',] }],
        popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],
        element: [{ type: ViewChild, args: ['element',] }]
    };
    return EditorFontFamilyComponent;
}(ToolBarToolComponent));

// tslint:disable:no-forward-ref
/**
 * A component which configures an existing ColorPickerComponent as a ToolBar tool.
 * To associate a `kendo-toolbar-colorpicker` with an Editor command that changes the
 * foreground or the background color of the text, use the `kendoEditorForeColor` or `kendoEditorBackColor` directive.
 */
var EditorColorPickerComponent = /** @class */ (function (_super) {
    __extends(EditorColorPickerComponent, _super);
    function EditorColorPickerComponent(editor, localization, dialogService) {
        var _this = _super.call(this) || this;
        _this.editor = editor;
        _this.localization = localization;
        _this.dialogService = dialogService;
        return _this;
    }
    Object.defineProperty(EditorColorPickerComponent.prototype, "title", {
        /**
         * @hidden
         */
        get: function () {
            return this.localization.get(this.editorCommand);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    EditorColorPickerComponent.prototype.handleValueChange = function (color) {
        this.editor.exec(this.editorCommand, color);
        this.editor.focus();
    };
    /**
     * @hidden
     */
    EditorColorPickerComponent.prototype.handleActiveColorClick = function (event) {
        event.preventOpen();
        this.handleValueChange(event.color);
    };
    Object.defineProperty(EditorColorPickerComponent.prototype, "outerWidth", {
        /**
         * @hidden
         */
        get: function () {
            if (this.element) {
                return outerWidth(this.element.nativeElement);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    EditorColorPickerComponent.prototype.openDialog = function () {
        var dialogSettings = {
            appendTo: this.editor.dialogContainer,
            content: ColorPickerDialogComponent
        };
        this.editor.toolbar.toggle(false);
        var dialogContent = this.dialogService.open(dialogSettings).content.instance;
        dialogContent.setData({
            editor: this.editor,
            value: this.value,
            title: this.title,
            editorCommand: this.editorCommand,
            paletteSettings: this.paletteSettings,
            icon: this.icon
        });
    };
    EditorColorPickerComponent.decorators = [
        { type: Component, args: [{
                    providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(function () { return EditorColorPickerComponent; }) }],
                    selector: 'kendo-toolbar-colorpicker',
                    template: "\n        <ng-template #toolbarTemplate>\n            <kendo-colorpicker\n                #colorpicker\n                [view]=\"'palette'\"\n                [format]=\"'hex'\"\n                [attr.title]=\"title\"\n                [icon]=\"icon\"\n                [value]=\"value\"\n                [paletteSettings]=\"paletteSettings\"\n                (valueChange)=\"handleValueChange($event)\"\n                (activeColorClick)=\"handleActiveColorClick($event)\"\n            >\n            </kendo-colorpicker>\n        </ng-template>\n        <ng-template #popupTemplate>\n            <button\n                tabindex=\"-1\"\n                type=\"button\"\n                kendoButton\n                class=\"k-overflow-button\"\n                [icon]=\"icon\"\n                [attr.title]=\"title\"\n                (click)=\"openDialog()\"\n            >\n                {{ title }}\n            </button>\n        </ng-template>\n    "
                },] },
    ];
    /** @nocollapse */
    EditorColorPickerComponent.ctorParameters = function () { return [
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService },
        { type: DialogService }
    ]; };
    EditorColorPickerComponent.propDecorators = {
        value: [{ type: Input }],
        icon: [{ type: Input }],
        paletteSettings: [{ type: Input }],
        editorCommand: [{ type: Input }],
        toolbarTemplate: [{ type: ViewChild, args: ['toolbarTemplate',] }],
        popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],
        element: [{ type: ViewChild, args: ['colorpicker', { read: ElementRef },] }]
    };
    return EditorColorPickerComponent;
}(ToolBarToolComponent));

var popupWrapperWidth = '190px';
var popupWrapperHeight = '164px'; // Set to '192px' when TableWizard button is added;
/**
 * A toolbar component which allows the user to create and insert a table in the Editor's content.
 *
 * @example
 * ```ts-no-run
 * <kendo-editor-insert-table-button></kendo-editor-insert-table-button>
 * ```
 */
var EditorInsertTableButtonComponent = /** @class */ (function (_super) {
    __extends(EditorInsertTableButtonComponent, _super);
    function EditorInsertTableButtonComponent(editor, localization, popupService, dialogService) {
        var _this = _super.call(this) || this;
        _this.editor = editor;
        _this.localization = localization;
        _this.popupService = popupService;
        _this.dialogService = dialogService;
        _this.open = false;
        _this.buttonBlurred = new EventEmitter();
        _this.cellClicked = new EventEmitter();
        _this.subs = _this.editor.stateChange.subscribe(function (_a) {
            var insertTable = _a.insertTable;
            _this.disabled = insertTable;
        });
        _this.subs = _this.buttonBlurred.pipe(concatMap(function () { return interval(200).pipe(take(1), takeUntil(_this.cellClicked)); }))
            .subscribe(function () {
            _this.toggle(false);
        });
        return _this;
    }
    EditorInsertTableButtonComponent.prototype.ngOnDestroy = function () {
        this.destroyPopup();
        this.subs.unsubscribe();
    };
    Object.defineProperty(EditorInsertTableButtonComponent.prototype, "outerWidth", {
        get: function () {
            if (this.element) {
                return outerWidth(this.element.nativeElement);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorInsertTableButtonComponent.prototype, "title", {
        get: function () {
            return this.localization.get('insertTable');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    EditorInsertTableButtonComponent.prototype.toggle = function (open) {
        this.open = (open === undefined) ? !this.open : open;
        this.destroyPopup();
        if (this.open) {
            this.createPopup();
        }
    };
    /**
     * @hidden
     */
    EditorInsertTableButtonComponent.prototype.openDialog = function () {
        var dialogSettings = {
            appendTo: this.editor.dialogContainer,
            content: InsertTableDialogComponent
        };
        this.editor.toolbar.toggle(false);
        var dialogContent = this.dialogService.open(dialogSettings).content.instance;
        dialogContent.setData({
            editor: this.editor
        });
    };
    /**
     * @hidden
     */
    EditorInsertTableButtonComponent.prototype.onBlur = function () {
        this.buttonBlurred.emit();
    };
    /**
     * @hidden
     */
    EditorInsertTableButtonComponent.prototype.onCellClick = function (args) {
        this.cellClicked.emit();
        this.toggle(false);
        this.editor.exec("insertTable", args);
    };
    /**
     * @hidden
     */
    EditorInsertTableButtonComponent.prototype.onTableWizardClick = function () {
        // this.toggle(false);
        // this.editor.openDialog("tableWizard");
    };
    EditorInsertTableButtonComponent.prototype.createPopup = function () {
        var horizontalAlign = this.editor.direction === "rtl" ? "right" : "left";
        var anchorPosition = { horizontal: horizontalAlign, vertical: "bottom" };
        var popupPosition = { horizontal: horizontalAlign, vertical: "top" };
        this.popupRef = this.popupService.open({
            anchor: this.element,
            anchorAlign: anchorPosition,
            animate: true,
            content: this.popupGridTemplate,
            popupAlign: popupPosition,
            popupClass: 'k-ct-popup k-group k-reset k-state-border-up',
            positionMode: 'absolute'
        });
        var popupWrapper = this.popupRef.popupElement;
        popupWrapper.style.width = popupWrapperWidth;
        popupWrapper.style.height = popupWrapperHeight;
        popupWrapper.setAttribute("dir", this.editor.direction);
    };
    EditorInsertTableButtonComponent.prototype.destroyPopup = function () {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
    };
    EditorInsertTableButtonComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:no-forward-ref
                    providers: [{ provide: ToolBarToolComponent, useExisting: forwardRef(function () { return EditorInsertTableButtonComponent; }) }],
                    selector: 'kendo-editor-insert-table-button',
                    template: "\n        <ng-template #toolbarTemplate>\n            <button type=\"button\" kendoButton #element [attr.title]=\"title\" [icon]=\"'table-insert'\" [disabled]=\"disabled\" (click)=\"toggle()\" (blur)=\"onBlur()\"></button>\n        </ng-template>\n        <ng-template #popupTemplate>\n            <button kendoButton [attr.title]=\"title\" [icon]=\"'table-insert'\" [disabled]=\"disabled\" (click)=\"openDialog()\">{{ title }}</button>\n        </ng-template>\n        <ng-template #popupGridTemplate>\n            <kendo-popup-table-grid (cellClick)=\"onCellClick($event)\" (tableWizardClick)=\"onTableWizardClick()\"></kendo-popup-table-grid>\n        </ng-template>\n    "
                },] },
    ];
    /** @nocollapse */
    EditorInsertTableButtonComponent.ctorParameters = function () { return [
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService },
        { type: PopupService },
        { type: DialogService }
    ]; };
    EditorInsertTableButtonComponent.propDecorators = {
        toolbarTemplate: [{ type: ViewChild, args: ['toolbarTemplate',] }],
        popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],
        element: [{ type: ViewChild, args: ['element',] }],
        popupGridTemplate: [{ type: ViewChild, args: ['popupGridTemplate',] }]
    };
    return EditorInsertTableButtonComponent;
}(ToolBarToolComponent));

/**
 * @hidden
 */
var PopupTableGridComponent = /** @class */ (function () {
    function PopupTableGridComponent() {
        this.cellClick = new EventEmitter();
        this.tableWizardClick = new EventEmitter();
        this.state = { rows: -1, cols: -1 };
        this.rows = 6;
        this.cols = 8;
    }
    Object.defineProperty(PopupTableGridComponent.prototype, "message", {
        get: function () {
            var _a = this.state, rows = _a.rows, cols = _a.cols;
            return "Create a " + (rows > -1 ? rows + 1 : '') + " " + (cols > -1 ? 'x' : '') + " " + (cols > -1 ? cols + 1 : '') + " table";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PopupTableGridComponent.prototype, "cells", {
        get: function () {
            return Array.from(Array(this.rows * this.cols).keys());
        },
        enumerable: true,
        configurable: true
    });
    PopupTableGridComponent.prototype.selected = function (index) {
        var _a = this.state, rows = _a.rows, cols = _a.cols;
        var cellRow = Math.floor(index / this.cols);
        var cellCol = index % this.cols;
        return cellRow <= rows && cellCol <= cols;
    };
    PopupTableGridComponent.prototype.setState = function (index) {
        var rows = Math.floor(index / this.cols);
        var cols = index % this.cols;
        this.state = { rows: rows, cols: cols };
    };
    PopupTableGridComponent.prototype.resetState = function () {
        this.state = { rows: -1, cols: -1 };
    };
    PopupTableGridComponent.prototype.insertTable = function () {
        this.cellClick.emit(this.state);
    };
    PopupTableGridComponent.prototype.openTableWizard = function () {
        this.tableWizardClick.emit();
    };
    PopupTableGridComponent.decorators = [
        { type: Component, args: [{
                    selector: 'kendo-popup-table-grid',
                    template: "\n        <div style=\"border-color: inherit;\" (mouseleave)=\"resetState()\" (click)=\"insertTable()\">\n            <span *ngFor=\"let i of cells\"\n                class=\"k-ct-cell\"\n                [class.k-state-selected]=\"selected(i)\"\n                [class.k-state-disabled]=\"!selected(i)\"\n                (mouseenter)=\"setState(i)\">\n            </span>\n        </div>\n        <div class=\"k-status\" unselectable=\"on\">{{ message }}</div>\n        <!-- uncomment when TableWizard is completed\n        <div class=\"k-editor-toolbar\" unselectable=\"on\">\n            <button type=\"button\" kendoButton class=\"k-tool\" [icon]=\"'table-wizard'\" (click)=\"openTableWizard()\" title=\"Table Wizard\">Table Wizard</button>\n        </div>\n        -->\n    "
                },] },
    ];
    PopupTableGridComponent.propDecorators = {
        cellClick: [{ type: Output }],
        tableWizardClick: [{ type: Output }]
    };
    return PopupTableGridComponent;
}());

/**
 * @hidden
 */
var commandIcons = {
    alignCenter: 'align-center',
    alignJustify: 'align-justify',
    alignLeft: 'align-left',
    alignRight: 'align-right',
    bold: 'bold',
    cleanFormatting: 'clear-css',
    createLink: 'link-horizontal',
    indent: 'indent-increase',
    insertFile: 'file-add',
    insertImage: 'image',
    insertOrderedList: 'list-ordered',
    insertUnorderedList: 'list-unordered',
    italic: 'italic',
    outdent: 'indent-decrease',
    redo: 'redo',
    strikethrough: 'strikethrough',
    subscript: 'sub-script',
    superscript: 'sup-script',
    underline: 'underline',
    undo: 'undo',
    unlink: 'unlink-horizontal',
    viewSource: 'html',
    foreColor: 'foreground-color',
    backColor: 'background',
    //table
    insertTable: 'table-insert',
    addColumnBefore: 'table-column-insert-left',
    addColumnAfter: 'table-column-insert-right',
    addRowBefore: 'table-row-insert-above',
    addRowAfter: 'table-row-insert-below',
    deleteRow: 'table-row-delete',
    deleteColumn: 'table-column-delete',
    mergeCells: 'cells-merge',
    splitCell: 'cell-split-horizontally',
    deleteTable: 'table-delete'
    // tableWizard: 'table-wizard'
};

/**
 * @hidden
 */
var EditorCommandBase = /** @class */ (function () {
    function EditorCommandBase(command, button, editor, localization) {
        this.command = command;
        this.button = button;
        this.editor = editor;
        this.localization = localization;
    }
    EditorCommandBase.prototype.ngOnInit = function () {
        var _this = this;
        this.subs = this.editor.stateChange.subscribe(this.onStateChange.bind(this));
        this.subs.add(this.button.click.subscribe((this.clickHandler.bind(this))));
        Promise.resolve(null).then(function () {
            var text = _this.localization.get(_this.command);
            if (text) {
                _this.button.showText = "overflow";
                _this.button.showIcon = "both";
                _this.button.text = text;
            }
            if (!_this.button.icon) {
                _this.button.icon = commandIcons[_this.command];
            }
            _this.button.title = text;
        });
    };
    EditorCommandBase.prototype.ngOnDestroy = function () {
        this.subs.unsubscribe();
    };
    // tslint:disable-next-line
    EditorCommandBase.prototype.clickHandler = function () { };
    // tslint:disable-next-line
    EditorCommandBase.prototype.onStateChange = function (_toolBarState) { };
    return EditorCommandBase;
}());

/**
 * @hidden
 */
var EditorCommandButton = /** @class */ (function (_super) {
    __extends(EditorCommandButton, _super);
    function EditorCommandButton(command, button, editor, localization) {
        var _this = _super.call(this, command, button, editor, localization) || this;
        _this.command = command;
        _this.button = button;
        _this.editor = editor;
        _this.localization = localization;
        return _this;
    }
    EditorCommandButton.prototype.clickHandler = function () {
        this.editor.exec(this.command);
        this.editor.focus();
    };
    EditorCommandButton.prototype.onStateChange = function (toolBarState) {
        this.button.selected = toolBarState[this.command];
    };
    return EditorCommandButton;
}(EditorCommandBase));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor AlignLeft tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAlignLeftButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAlignLeftButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorAlignLeftButtonDirective = /** @class */ (function (_super) {
    __extends(EditorAlignLeftButtonDirective, _super);
    function EditorAlignLeftButtonDirective(button, editor, localization) {
        return _super.call(this, 'alignLeft', button, editor, localization) || this;
    }
    EditorAlignLeftButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorAlignLeftButton]'
                },] },
    ];
    /** @nocollapse */
    EditorAlignLeftButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorAlignLeftButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor AlignCenter tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAlignCenterButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAlignCenterButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorAlignCenterButtonDirective = /** @class */ (function (_super) {
    __extends(EditorAlignCenterButtonDirective, _super);
    function EditorAlignCenterButtonDirective(button, editor, localization) {
        return _super.call(this, 'alignCenter', button, editor, localization) || this;
    }
    EditorAlignCenterButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorAlignCenterButton]'
                },] },
    ];
    /** @nocollapse */
    EditorAlignCenterButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorAlignCenterButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor AlignRight tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAlignRightButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAlignRightButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorAlignRightButtonDirective = /** @class */ (function (_super) {
    __extends(EditorAlignRightButtonDirective, _super);
    function EditorAlignRightButtonDirective(button, editor, localization) {
        return _super.call(this, 'alignRight', button, editor, localization) || this;
    }
    EditorAlignRightButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorAlignRightButton]'
                },] },
    ];
    /** @nocollapse */
    EditorAlignRightButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorAlignRightButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor AlignJustify tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAlignJustifyButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAlignJustifyButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorAlignJustifyButtonDirective = /** @class */ (function (_super) {
    __extends(EditorAlignJustifyButtonDirective, _super);
    function EditorAlignJustifyButtonDirective(button, editor, localization) {
        return _super.call(this, 'alignJustify', button, editor, localization) || this;
    }
    EditorAlignJustifyButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorAlignJustifyButton]'
                },] },
    ];
    /** @nocollapse */
    EditorAlignJustifyButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorAlignJustifyButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Redo tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorRedoButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorRedoButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorRedoButtonDirective = /** @class */ (function (_super) {
    __extends(EditorRedoButtonDirective, _super);
    function EditorRedoButtonDirective(button, editor, localization) {
        return _super.call(this, 'redo', button, editor, localization) || this;
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line:typedef
    EditorRedoButtonDirective.prototype.onStateChange = function (toolBarState) {
        this.button.disabled = toolBarState[this.command];
    };
    EditorRedoButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorRedoButton]'
                },] },
    ];
    /** @nocollapse */
    EditorRedoButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorRedoButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Undo tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorUndoButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorUndoButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorUndoButtonDirective = /** @class */ (function (_super) {
    __extends(EditorUndoButtonDirective, _super);
    function EditorUndoButtonDirective(button, editor, localization) {
        return _super.call(this, 'undo', button, editor, localization) || this;
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line:typedef
    EditorUndoButtonDirective.prototype.onStateChange = function (toolBarState) {
        this.button.disabled = toolBarState[this.command];
    };
    EditorUndoButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorUndoButton]'
                },] },
    ];
    /** @nocollapse */
    EditorUndoButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorUndoButtonDirective;
}(EditorCommandButton));

/**
 * @hidden
 */
var EditorCommandDialog = /** @class */ (function (_super) {
    __extends(EditorCommandDialog, _super);
    function EditorCommandDialog(dialog, button, editor, localization) {
        var _this = _super.call(this, dialog, button, editor, localization) || this;
        _this.dialog = dialog;
        _this.button = button;
        _this.editor = editor;
        _this.localization = localization;
        return _this;
    }
    EditorCommandDialog.prototype.clickHandler = function () {
        this.editor.openDialog(this.dialog);
    };
    return EditorCommandDialog;
}(EditorCommandBase));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor InsertImage tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorInsertImageButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorInsertImageButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorInsertImageButtonDirective = /** @class */ (function (_super) {
    __extends(EditorInsertImageButtonDirective, _super);
    function EditorInsertImageButtonDirective(button, editor, localization) {
        return _super.call(this, 'insertImage', button, editor, localization) || this;
    }
    EditorInsertImageButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorInsertImageButton]'
                },] },
    ];
    /** @nocollapse */
    EditorInsertImageButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorInsertImageButtonDirective;
}(EditorCommandDialog));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Indent tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorIndentButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorIndentButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorIndentButtonDirective = /** @class */ (function (_super) {
    __extends(EditorIndentButtonDirective, _super);
    function EditorIndentButtonDirective(button, editor, localization) {
        return _super.call(this, 'indent', button, editor, localization) || this;
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line:typedef
    EditorIndentButtonDirective.prototype.onStateChange = function (toolBarState) {
        this.button.disabled = !toolBarState[this.command];
    };
    EditorIndentButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorIndentButton]'
                },] },
    ];
    /** @nocollapse */
    EditorIndentButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorIndentButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Outdent tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorOutdentButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorOutdentButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorOutdentButtonDirective = /** @class */ (function (_super) {
    __extends(EditorOutdentButtonDirective, _super);
    function EditorOutdentButtonDirective(button, editor, localization) {
        return _super.call(this, 'outdent', button, editor, localization) || this;
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line:typedef
    EditorOutdentButtonDirective.prototype.onStateChange = function (toolBarState) {
        this.button.disabled = !toolBarState[this.command];
    };
    EditorOutdentButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorOutdentButton]'
                },] },
    ];
    /** @nocollapse */
    EditorOutdentButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorOutdentButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor CreateLink tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorCreateLinkButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorCreateLinkButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorCreateLinkButtonDirective = /** @class */ (function (_super) {
    __extends(EditorCreateLinkButtonDirective, _super);
    function EditorCreateLinkButtonDirective(button, editor, localization) {
        return _super.call(this, 'createLink', button, editor, localization) || this;
    }
    EditorCreateLinkButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorCreateLinkButton]'
                },] },
    ];
    /** @nocollapse */
    EditorCreateLinkButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorCreateLinkButtonDirective;
}(EditorCommandDialog));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Unlink tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorUnlinkButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorUnlinkButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorUnlinkButtonDirective = /** @class */ (function (_super) {
    __extends(EditorUnlinkButtonDirective, _super);
    function EditorUnlinkButtonDirective(button, editor, localization) {
        return _super.call(this, 'unlink', button, editor, localization) || this;
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line:typedef
    EditorUnlinkButtonDirective.prototype.onStateChange = function (toolBarState) {
        this.button.disabled = toolBarState.unlink;
    };
    EditorUnlinkButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorUnlinkButton]'
                },] },
    ];
    /** @nocollapse */
    EditorUnlinkButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorUnlinkButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor InsertOrderedList tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorInsertOrderedListButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorInsertOrderedListButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorInsertOrderedListButtonDirective = /** @class */ (function (_super) {
    __extends(EditorInsertOrderedListButtonDirective, _super);
    function EditorInsertOrderedListButtonDirective(button, editor, localization) {
        return _super.call(this, 'insertOrderedList', button, editor, localization) || this;
    }
    EditorInsertOrderedListButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorInsertOrderedListButton]'
                },] },
    ];
    /** @nocollapse */
    EditorInsertOrderedListButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorInsertOrderedListButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor InsertUnorderedList tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorInsertUnorderedListButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorInsertUnorderedListButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorInsertUnorderedListButtonDirective = /** @class */ (function (_super) {
    __extends(EditorInsertUnorderedListButtonDirective, _super);
    function EditorInsertUnorderedListButtonDirective(button, editor, localization) {
        return _super.call(this, 'insertUnorderedList', button, editor, localization) || this;
    }
    EditorInsertUnorderedListButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorInsertUnorderedListButton]'
                },] },
    ];
    /** @nocollapse */
    EditorInsertUnorderedListButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorInsertUnorderedListButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor ViewSource tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorViewSourceButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorViewSourceButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorViewSourceButtonDirective = /** @class */ (function (_super) {
    __extends(EditorViewSourceButtonDirective, _super);
    function EditorViewSourceButtonDirective(button, editor, localization) {
        return _super.call(this, 'viewSource', button, editor, localization) || this;
    }
    EditorViewSourceButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorViewSourceButton]'
                },] },
    ];
    /** @nocollapse */
    EditorViewSourceButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorViewSourceButtonDirective;
}(EditorCommandDialog));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Bold tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorBoldButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorBoldButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorBoldButtonDirective = /** @class */ (function (_super) {
    __extends(EditorBoldButtonDirective, _super);
    function EditorBoldButtonDirective(button, editor, localization) {
        return _super.call(this, 'bold', button, editor, localization) || this;
    }
    EditorBoldButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorBoldButton]'
                },] },
    ];
    /** @nocollapse */
    EditorBoldButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorBoldButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Italic tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorItalicButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorItalicButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorItalicButtonDirective = /** @class */ (function (_super) {
    __extends(EditorItalicButtonDirective, _super);
    function EditorItalicButtonDirective(button, editor, localization) {
        return _super.call(this, 'italic', button, editor, localization) || this;
    }
    EditorItalicButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorItalicButton]'
                },] },
    ];
    /** @nocollapse */
    EditorItalicButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorItalicButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Underline tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorUnderlineButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorUnderlineButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorUnderlineButtonDirective = /** @class */ (function (_super) {
    __extends(EditorUnderlineButtonDirective, _super);
    function EditorUnderlineButtonDirective(button, editor, localization) {
        return _super.call(this, 'underline', button, editor, localization) || this;
    }
    EditorUnderlineButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorUnderlineButton]'
                },] },
    ];
    /** @nocollapse */
    EditorUnderlineButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorUnderlineButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Strikethrough tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorStrikethroughButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorStrikethroughButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorStrikethroughButtonDirective = /** @class */ (function (_super) {
    __extends(EditorStrikethroughButtonDirective, _super);
    function EditorStrikethroughButtonDirective(button, editor, localization) {
        return _super.call(this, 'strikethrough', button, editor, localization) || this;
    }
    EditorStrikethroughButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorStrikethroughButton]'
                },] },
    ];
    /** @nocollapse */
    EditorStrikethroughButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorStrikethroughButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Subscript tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorSubscriptButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorSubscriptButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorSubscriptButtonDirective = /** @class */ (function (_super) {
    __extends(EditorSubscriptButtonDirective, _super);
    function EditorSubscriptButtonDirective(button, editor, localization) {
        return _super.call(this, 'subscript', button, editor, localization) || this;
    }
    EditorSubscriptButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorSubscriptButton]'
                },] },
    ];
    /** @nocollapse */
    EditorSubscriptButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorSubscriptButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Superscript tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `selected` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorSuperscriptButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon that is applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorSuperscriptButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorSuperscriptButtonDirective = /** @class */ (function (_super) {
    __extends(EditorSuperscriptButtonDirective, _super);
    function EditorSuperscriptButtonDirective(button, editor, localization) {
        return _super.call(this, 'superscript', button, editor, localization) || this;
    }
    EditorSuperscriptButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorSuperscriptButton]'
                },] },
    ];
    /** @nocollapse */
    EditorSuperscriptButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorSuperscriptButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor 'Insert File' tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorInsertFileButton></kendo-toolbar-button>
 * ```
 */
var EditorInsertFileButtonDirective = /** @class */ (function (_super) {
    __extends(EditorInsertFileButtonDirective, _super);
    function EditorInsertFileButtonDirective(button, editor, localization) {
        return _super.call(this, 'insertFile', button, editor, localization) || this;
    }
    EditorInsertFileButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorInsertFileButton]'
                },] },
    ];
    /** @nocollapse */
    EditorInsertFileButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorInsertFileButtonDirective;
}(EditorCommandDialog));

/**
 * A directive which configures an `EditorColorPickerComponent`
 * for manipulating the foreground color of the text
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 */
var EditorForeColorDirective = /** @class */ (function () {
    function EditorForeColorDirective(colorPicker) {
        this.colorPicker = colorPicker;
        this.colorPicker.icon = commandIcons.foreColor;
        this.colorPicker.editorCommand = 'foreColor';
    }
    EditorForeColorDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoEditorForeColor]'
                },] },
    ];
    /** @nocollapse */
    EditorForeColorDirective.ctorParameters = function () { return [
        { type: EditorColorPickerComponent }
    ]; };
    return EditorForeColorDirective;
}());

/**
 * A directive which configures an `EditorColorPickerComponent`
 * for manipulating the background color of the text
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 */
var EditorBackColorDirective = /** @class */ (function () {
    function EditorBackColorDirective(colorPicker) {
        this.colorPicker = colorPicker;
        this.colorPicker.icon = commandIcons.backColor;
        this.colorPicker.editorCommand = 'backColor';
    }
    EditorBackColorDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoEditorBackColor]'
                },] },
    ];
    /** @nocollapse */
    EditorBackColorDirective.ctorParameters = function () { return [
        { type: EditorColorPickerComponent }
    ]; };
    return EditorBackColorDirective;
}());

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor Clean Formatting tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorCleanFormattingButton></kendo-toolbar-button>
 * ```
 *
 * The following example demonstrates how to change the default icon applied by the directive.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorCleanFormattingButton [icon]="'blogger'"></kendo-toolbar-button>
 * ```
 */
var EditorCleanFormattingButtonDirective = /** @class */ (function (_super) {
    __extends(EditorCleanFormattingButtonDirective, _super);
    function EditorCleanFormattingButtonDirective(button, editor, localization) {
        return _super.call(this, 'cleanFormatting', button, editor, localization) || this;
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line
    EditorCleanFormattingButtonDirective.prototype.onStateChange = function (toolBarState) {
        this.button.disabled = toolBarState.cleanFormatting;
    };
    EditorCleanFormattingButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorCleanFormattingButton]'
                },] },
    ];
    /** @nocollapse */
    EditorCleanFormattingButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorCleanFormattingButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor AddColumnBefore tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAddColumnBeforeButton></kendo-toolbar-button>
 * ```
 */
var EditorAddColumnBeforeButtonDirective = /** @class */ (function (_super) {
    __extends(EditorAddColumnBeforeButtonDirective, _super);
    function EditorAddColumnBeforeButtonDirective(button, editor, localization) {
        return _super.call(this, 'addColumnBefore', button, editor, localization) || this;
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line
    EditorAddColumnBeforeButtonDirective.prototype.onStateChange = function (toolBarState) {
        this.button.disabled = toolBarState.addColumnBefore;
    };
    EditorAddColumnBeforeButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorAddColumnBeforeButton]'
                },] },
    ];
    /** @nocollapse */
    EditorAddColumnBeforeButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorAddColumnBeforeButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor AddColumnAfter tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAddColumnAfterButton></kendo-toolbar-button>
 * ```
 */
var EditorAddColumnAfterButtonDirective = /** @class */ (function (_super) {
    __extends(EditorAddColumnAfterButtonDirective, _super);
    function EditorAddColumnAfterButtonDirective(button, editor, localization) {
        return _super.call(this, 'addColumnAfter', button, editor, localization) || this;
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line
    EditorAddColumnAfterButtonDirective.prototype.onStateChange = function (toolBarState) {
        this.button.disabled = toolBarState.addColumnAfter;
    };
    EditorAddColumnAfterButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorAddColumnAfterButton]'
                },] },
    ];
    /** @nocollapse */
    EditorAddColumnAfterButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorAddColumnAfterButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor AddRowBefore tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAddRowBeforeButton></kendo-toolbar-button>
 * ```
 */
var EditorAddRowBeforeButtonDirective = /** @class */ (function (_super) {
    __extends(EditorAddRowBeforeButtonDirective, _super);
    function EditorAddRowBeforeButtonDirective(button, editor, localization) {
        return _super.call(this, 'addRowBefore', button, editor, localization) || this;
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line
    EditorAddRowBeforeButtonDirective.prototype.onStateChange = function (toolBarState) {
        this.button.disabled = toolBarState.addRowBefore;
    };
    EditorAddRowBeforeButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorAddRowBeforeButton]'
                },] },
    ];
    /** @nocollapse */
    EditorAddRowBeforeButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorAddRowBeforeButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor AddRowAfter tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorAddRowAfterButton></kendo-toolbar-button>
 * ```
 */
var EditorAddRowAfterButtonDirective = /** @class */ (function (_super) {
    __extends(EditorAddRowAfterButtonDirective, _super);
    function EditorAddRowAfterButtonDirective(button, editor, localization) {
        return _super.call(this, 'addRowAfter', button, editor, localization) || this;
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line
    EditorAddRowAfterButtonDirective.prototype.onStateChange = function (toolBarState) {
        this.button.disabled = toolBarState.addRowAfter;
    };
    EditorAddRowAfterButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorAddRowAfterButton]'
                },] },
    ];
    /** @nocollapse */
    EditorAddRowAfterButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorAddRowAfterButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor DeleteColumn tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorDeleteColumnButton></kendo-toolbar-button>
 * ```
 */
var EditorDeleteColumnButtonDirective = /** @class */ (function (_super) {
    __extends(EditorDeleteColumnButtonDirective, _super);
    function EditorDeleteColumnButtonDirective(button, editor, localization) {
        return _super.call(this, 'deleteColumn', button, editor, localization) || this;
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line
    EditorDeleteColumnButtonDirective.prototype.onStateChange = function (toolBarState) {
        this.button.disabled = toolBarState.deleteColumn;
    };
    EditorDeleteColumnButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorDeleteColumnButton]'
                },] },
    ];
    /** @nocollapse */
    EditorDeleteColumnButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorDeleteColumnButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor DeleteRow tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorDeleteRowButton></kendo-toolbar-button>
 * ```
 */
var EditorDeleteRowButtonDirective = /** @class */ (function (_super) {
    __extends(EditorDeleteRowButtonDirective, _super);
    function EditorDeleteRowButtonDirective(button, editor, localization) {
        return _super.call(this, 'deleteRow', button, editor, localization) || this;
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line
    EditorDeleteRowButtonDirective.prototype.onStateChange = function (toolBarState) {
        this.button.disabled = toolBarState.deleteRow;
    };
    EditorDeleteRowButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorDeleteRowButton]'
                },] },
    ];
    /** @nocollapse */
    EditorDeleteRowButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorDeleteRowButtonDirective;
}(EditorCommandButton));

/**
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor DeleteTable tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorDeleteTableButton></kendo-toolbar-button>
 * ```
 */
var EditorDeleteTableButtonDirective = /** @class */ (function (_super) {
    __extends(EditorDeleteTableButtonDirective, _super);
    function EditorDeleteTableButtonDirective(button, editor, localization) {
        return _super.call(this, 'deleteTable', button, editor, localization) || this;
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line
    EditorDeleteTableButtonDirective.prototype.onStateChange = function (toolBarState) {
        this.button.disabled = toolBarState.deleteTable;
    };
    EditorDeleteTableButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorDeleteTableButton]'
                },] },
    ];
    /** @nocollapse */
    EditorDeleteTableButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorDeleteTableButtonDirective;
}(EditorCommandButton));

/**
 * @hidden
 *
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor MergeCells tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorMergeCellsButton></kendo-toolbar-button>
 * ```
 */
var EditorMergeCellsButtonDirective = /** @class */ (function (_super) {
    __extends(EditorMergeCellsButtonDirective, _super);
    function EditorMergeCellsButtonDirective(button, editor, localization) {
        return _super.call(this, 'mergeCells', button, editor, localization) || this;
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line
    EditorMergeCellsButtonDirective.prototype.onStateChange = function (toolBarState) {
        this.button.disabled = toolBarState.mergeCells;
    };
    EditorMergeCellsButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorMergeCellsButton]'
                },] },
    ];
    /** @nocollapse */
    EditorMergeCellsButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorMergeCellsButtonDirective;
}(EditorCommandButton));

/**
 * @hidden
 *
 * A directive which configures an existing `ToolBarButtonComponent` as an Editor SplitCell tool
 * ([see example]({% slug toolbartools_editor %}#toc-built-in-tools)).
 * The directive will predefine the `icon` and `click` event handlers of the button.
 * In addition, the directive updates the `disabled` state of the button according to the cursor position in the editing area.
 *
 * @example
 * ```ts-no-run
 * <kendo-toolbar-button kendoEditorSplitCellButton></kendo-toolbar-button>
 * ```
 */
var EditorSplitCellButtonDirective = /** @class */ (function (_super) {
    __extends(EditorSplitCellButtonDirective, _super);
    function EditorSplitCellButtonDirective(button, editor, localization) {
        return _super.call(this, 'splitCell', button, editor, localization) || this;
    }
    /**
     * @hidden
     */
    // tslint:disable-next-line
    EditorSplitCellButtonDirective.prototype.onStateChange = function (toolBarState) {
        this.button.disabled = toolBarState.splitCell;
    };
    EditorSplitCellButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'kendo-toolbar-button[kendoEditorSplitCellButton]'
                },] },
    ];
    /** @nocollapse */
    EditorSplitCellButtonDirective.ctorParameters = function () { return [
        { type: ToolBarButtonComponent },
        { type: EditorComponent, decorators: [{ type: Host }] },
        { type: EditorLocalizationService }
    ]; };
    return EditorSplitCellButtonDirective;
}(EditorCommandButton));

/**
 * @hidden
 */
var Messages = /** @class */ (function (_super) {
    __extends(Messages, _super);
    function Messages() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Messages.propDecorators = {
        alignCenter: [{ type: Input }],
        alignJustify: [{ type: Input }],
        alignLeft: [{ type: Input }],
        alignRight: [{ type: Input }],
        backColor: [{ type: Input }],
        bold: [{ type: Input }],
        cleanFormatting: [{ type: Input }],
        createLink: [{ type: Input }],
        fontFamily: [{ type: Input }],
        fontSize: [{ type: Input }],
        foreColor: [{ type: Input }],
        format: [{ type: Input }],
        indent: [{ type: Input }],
        insertFile: [{ type: Input }],
        insertImage: [{ type: Input }],
        insertOrderedList: [{ type: Input }],
        insertUnorderedList: [{ type: Input }],
        italic: [{ type: Input }],
        outdent: [{ type: Input }],
        redo: [{ type: Input }],
        strikethrough: [{ type: Input }],
        subscript: [{ type: Input }],
        superscript: [{ type: Input }],
        underline: [{ type: Input }],
        undo: [{ type: Input }],
        unlink: [{ type: Input }],
        viewSource: [{ type: Input }],
        insertTable: [{ type: Input }],
        addColumnBefore: [{ type: Input }],
        addColumnAfter: [{ type: Input }],
        addRowBefore: [{ type: Input }],
        addRowAfter: [{ type: Input }],
        deleteColumn: [{ type: Input }],
        deleteRow: [{ type: Input }],
        deleteTable: [{ type: Input }],
        dialogApply: [{ type: Input }],
        dialogCancel: [{ type: Input }],
        dialogInsert: [{ type: Input }],
        dialogUpdate: [{ type: Input }],
        fileText: [{ type: Input }],
        fileTitle: [{ type: Input }],
        fileWebAddress: [{ type: Input }],
        imageAltText: [{ type: Input }],
        imageHeight: [{ type: Input }],
        imageWebAddress: [{ type: Input }],
        imageWidth: [{ type: Input }],
        linkOpenInNewWindow: [{ type: Input }],
        linkText: [{ type: Input }],
        linkTitle: [{ type: Input }],
        linkWebAddress: [{ type: Input }]
    };
    return Messages;
}(ComponentMessages));

/**
 * @hidden
 */
var LocalizedMessagesDirective = /** @class */ (function (_super) {
    __extends(LocalizedMessagesDirective, _super);
    function LocalizedMessagesDirective(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    LocalizedMessagesDirective.decorators = [
        { type: Directive, args: [{
                    providers: [
                        {
                            provide: Messages,
                            // tslint:disable-next-line:no-forward-ref
                            useExisting: forwardRef(function () { return LocalizedMessagesDirective; })
                        }
                    ],
                    selector: '[kendoEditorLocalizedMessages]'
                },] },
    ];
    /** @nocollapse */
    LocalizedMessagesDirective.ctorParameters = function () { return [
        { type: LocalizationService }
    ]; };
    return LocalizedMessagesDirective;
}(Messages));

/**
 * Custom component messages override default component messages
 * ([see example]({% slug globalization_editor %}#toc-localization)).
 */
var CustomMessagesComponent = /** @class */ (function (_super) {
    __extends(CustomMessagesComponent, _super);
    function CustomMessagesComponent(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    Object.defineProperty(CustomMessagesComponent.prototype, "override", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    CustomMessagesComponent.decorators = [
        { type: Component, args: [{
                    providers: [
                        {
                            provide: Messages,
                            // tslint:disable-next-line:no-forward-ref
                            useExisting: forwardRef(function () { return CustomMessagesComponent; })
                        }
                    ],
                    selector: 'kendo-editor-messages',
                    template: ""
                },] },
    ];
    /** @nocollapse */
    CustomMessagesComponent.ctorParameters = function () { return [
        { type: LocalizationService }
    ]; };
    return CustomMessagesComponent;
}(Messages));

/**
 * @hidden
 */
var FontFamilyDropDownListComponent = /** @class */ (function () {
    function FontFamilyDropDownListComponent() {
        this.valueChange = new EventEmitter();
    }
    FontFamilyDropDownListComponent.prototype.onValueChange = function (tag) {
        this.valueChange.emit(tag);
    };
    FontFamilyDropDownListComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:no-forward-ref
                    selector: 'kendo-editor-fontfamily-dropdownlist',
                    template: "\n        <kendo-dropdownlist\n            #element\n            [defaultItem]=\"defaultItem\"\n            [textField]=\"'text'\"\n            [valueField]=\"'fontName'\"\n            [data]=\"data\"\n            [(value)]=\"value\"\n            [valuePrimitive]=\"true\"\n            [itemDisabled]=\"itemDisabled\"\n            [attr.title]=\"title\"\n            (valueChange)=\"onValueChange($event)\"\n        >\n            <ng-template kendoDropDownListItemTemplate let-dataItem>\n                <span [ngStyle]=\"{ 'font-family': dataItem.fontName }\">\n                    {{ dataItem.text }}\n                </span>\n            </ng-template>\n        </kendo-dropdownlist>\n    "
                },] },
    ];
    FontFamilyDropDownListComponent.propDecorators = {
        data: [{ type: Input }],
        value: [{ type: Input }],
        defaultItem: [{ type: Input }],
        itemDisabled: [{ type: Input }],
        title: [{ type: Input }],
        valueChange: [{ type: Output }],
        element: [{ type: ViewChild, args: ['element',] }]
    };
    return FontFamilyDropDownListComponent;
}());

/**
 * @hidden
 */
var FontSizeDropDownListComponent = /** @class */ (function () {
    function FontSizeDropDownListComponent() {
        this.valueChange = new EventEmitter();
    }
    FontSizeDropDownListComponent.prototype.onValueChange = function (size) {
        this.valueChange.emit(size);
    };
    FontSizeDropDownListComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:no-forward-ref
                    selector: 'kendo-editor-fontsize-dropdownlist',
                    template: "\n        <kendo-dropdownlist\n            #element\n            [defaultItem]=\"defaultItem\"\n            [textField]=\"'text'\"\n            [valueField]=\"'size'\"\n            [data]=\"data\"\n            [(value)]=\"value\"\n            [valuePrimitive]=\"true\"\n            [itemDisabled]=\"itemDisabled\"\n            [attr.title]=\"title\"\n            (valueChange)=\"onValueChange($event)\"\n        >\n        </kendo-dropdownlist>\n    "
                },] },
    ];
    FontSizeDropDownListComponent.propDecorators = {
        data: [{ type: Input }],
        value: [{ type: Input }],
        defaultItem: [{ type: Input }],
        itemDisabled: [{ type: Input }],
        title: [{ type: Input }],
        valueChange: [{ type: Output }],
        element: [{ type: ViewChild, args: ['element',] }]
    };
    return FontSizeDropDownListComponent;
}());

var COMPONENT_DIRECTIVES = [
    //alignment
    EditorAlignLeftButtonDirective,
    EditorAlignCenterButtonDirective,
    EditorAlignRightButtonDirective,
    EditorAlignJustifyButtonDirective,
    //file
    EditorInsertFileButtonDirective,
    //history
    EditorRedoButtonDirective,
    EditorUndoButtonDirective,
    //image
    EditorInsertImageButtonDirective,
    //indent
    EditorIndentButtonDirective,
    EditorOutdentButtonDirective,
    //link
    EditorCreateLinkButtonDirective,
    EditorUnlinkButtonDirective,
    //list
    EditorInsertOrderedListButtonDirective,
    EditorInsertUnorderedListButtonDirective,
    //source
    EditorViewSourceButtonDirective,
    //typographical emphasis
    EditorBoldButtonDirective,
    EditorItalicButtonDirective,
    EditorUnderlineButtonDirective,
    EditorStrikethroughButtonDirective,
    EditorSubscriptButtonDirective,
    EditorSuperscriptButtonDirective,
    //color
    EditorForeColorDirective,
    EditorBackColorDirective,
    //clear format
    EditorCleanFormattingButtonDirective,
    //table
    EditorAddColumnBeforeButtonDirective,
    EditorAddColumnAfterButtonDirective,
    EditorAddRowBeforeButtonDirective,
    EditorAddRowAfterButtonDirective,
    EditorDeleteColumnButtonDirective,
    EditorDeleteRowButtonDirective,
    EditorDeleteTableButtonDirective,
    EditorMergeCellsButtonDirective,
    EditorSplitCellButtonDirective,
    // EditorTableWizardButtonDirective,
    //localization
    CustomMessagesComponent,
    LocalizedMessagesDirective
];
var TOOLBAR_TOOLS = [
    EditorFontSizeComponent,
    EditorFontFamilyComponent,
    EditorFormatComponent,
    EditorColorPickerComponent,
    EditorInsertTableButtonComponent
];
var TOOLBAR_DIALOGS = [
    FileLinkDialogComponent,
    ImageDialogComponent,
    SourceDialogComponent,
    FormatDialogComponent,
    ColorPickerDialogComponent,
    FontFamilyDialogComponent,
    FontSizeDialogComponent,
    InsertTableDialogComponent
    // TableWizardDialogComponent
    // Table Wizard Building Blocks
    // TableSettingsComponent,
    // CellSettingsComponent,
    // AccessibilitySettingsComponent
];
var INTERNAL_COMPONENTS = [
    PopupTableGridComponent,
    FormatDropDownListComponent,
    FontFamilyDropDownListComponent,
    FontSizeDropDownListComponent
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}) definition for the Editor component.
 *
 * The package exports:
 * - `EditorComponent`&mdash;The `EditorComponent` class.
 * - `EditorButtonDirective`&mdash;The `EditorButton` directive class.
 * - `EditorDropDownDirective`&mdash;The `EditorDropDown` directive class.
 * - `EditorDialogDirective`&mdash;The `EditorDialog` directive class.
 * - `ToolBarDropDownListComponent`&mdash;The `ToolBarDropDownListComponent` directive class.
 * - `ButtonModule`&mdash;The `KendoButton` module.
 * - `ToolBarModule`&mdash;The `KendoToolBar` module.
 *
 *  * @example
 *
 * ```ts-no-run
 * // Import the Editor module
 * import { EditorModule } from '@progress/kendo-angular-editor';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare the app component
 *     imports:      [BrowserModule, EditorModule], // import the Editor module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
var EditorModule = /** @class */ (function () {
    function EditorModule() {
    }
    EditorModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        EditorComponent,
                        COMPONENT_DIRECTIVES,
                        TOOLBAR_TOOLS,
                        TOOLBAR_DIALOGS,
                        INTERNAL_COMPONENTS
                    ],
                    entryComponents: [
                        TOOLBAR_DIALOGS
                    ],
                    exports: [
                        EditorComponent,
                        COMPONENT_DIRECTIVES,
                        TOOLBAR_TOOLS,
                        ToolBarModule,
                        ButtonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        //needed for unit tests
                        INTERNAL_COMPONENTS
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        //Kendo UI Angular Modules
                        ButtonModule,
                        ColorPickerModule,
                        DialogModule,
                        DropDownsModule,
                        NumericTextBoxModule,
                        ToolBarModule,
                        TextBoxModule
                    ]
                },] },
    ];
    return EditorModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { ColorPickerDialogComponent, FileLinkDialogComponent, FontFamilyDialogComponent, FontSizeDialogComponent, FormatDialogComponent, ImageDialogComponent, InsertTableDialogComponent, SourceDialogComponent, CustomMessagesComponent, EditorLocalizationService, LocalizedMessagesDirective, Messages, EditorAlignCenterButtonDirective, EditorAlignJustifyButtonDirective, EditorAlignLeftButtonDirective, EditorAlignRightButtonDirective, EditorBackColorDirective, EditorColorPickerComponent, EditorForeColorDirective, EditorCleanFormattingButtonDirective, FontFamilyDropDownListComponent, EditorFontFamilyComponent, FontSizeDropDownListComponent, EditorFontSizeComponent, FormatDropDownListComponent, EditorFormatComponent, EditorRedoButtonDirective, EditorUndoButtonDirective, EditorInsertImageButtonDirective, EditorIndentButtonDirective, EditorOutdentButtonDirective, EditorCreateLinkButtonDirective, EditorInsertFileButtonDirective, EditorUnlinkButtonDirective, EditorInsertOrderedListButtonDirective, EditorInsertUnorderedListButtonDirective, EditorCommandBase, EditorCommandButton, EditorCommandDialog, EditorViewSourceButtonDirective, EditorAddColumnAfterButtonDirective, EditorAddColumnBeforeButtonDirective, EditorAddRowAfterButtonDirective, EditorAddRowBeforeButtonDirective, EditorDeleteColumnButtonDirective, EditorDeleteRowButtonDirective, EditorDeleteTableButtonDirective, EditorInsertTableButtonComponent, EditorMergeCellsButtonDirective, EditorSplitCellButtonDirective, PopupTableGridComponent, EditorBoldButtonDirective, EditorItalicButtonDirective, EditorStrikethroughButtonDirective, EditorSubscriptButtonDirective, EditorSuperscriptButtonDirective, EditorUnderlineButtonDirective, EditorComponent, EditorModule };
